@{
    ViewData["Title"] = "CDS Gantt";
}

<style>
    html {
        font-size: 14px;
        font-family: Arial, Helvetica, sans-serif;
    }
</style>
<title>CDS Gantt</title>


<link href="~/css/default-ocean-blue.css" rel="stylesheet" />
<script src="~/js/jquery-3.7.0.min.js"></script>
<script src="~/js/kendo.all.min.js"></script>

<script src="~/js/kendo-ui-license.js"></script>


<div id="example">
    <a class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md" target="_blank" href="@ViewBag.ProjectResources">Project Resources</a>
    <div id="gantt"></div>

    <style>
        .k-gantt {
            font-family: "DejaVu Sans", "Arial", sans-serif;
        }

        /* Hide toolbars during export */
        .k-pdf-export .k-gantt-toolbar {
            display: none;
        }
    </style>

    <script>

        // ================= Gantt data access helper functions ==================

        // Enum for Dependency types
        // Make sure these value are in sync with the backend type definition
        const DependencyType = {
            FinishFinish: 0,
            FinishStart: 1,
            StartFinish: 2,
            StartStart: 3,
        }

        // Enum for day of week
        const DayOfWeek = {
            SUNDAY: 0,
            MONDAY: 1,
            TUESDAY: 2,
            WEDNESDAY: 3,
            THURSDAY: 4,
            FRIDAY: 5,
            SATURDAY: 6,
        }

        const MS_IN_A_DAY = 1000 * 60 * 60 * 24

        // GanttView instance access methods
        function getGanttDataSource() {
            return $('#gantt').data('kendoGantt').dataSource
        }

        function getGanttTasks() {
            return $('#gantt').data('kendoGantt').dataSource.data()
        }

        function getGanttDependencies() {
            return $('#gantt').data('kendoGantt').dependencies.data()
        }

        function getGanttAssignments() {
            return $('#gantt').data('kendoGantt').assignments.dataSource.data()
        }
        
        function refreshGanntView() {
            $('#gantt').data('kendoGantt')?.refresh()
        }

        // ==========================================================================

        var baselineSet = false;

        function calcVariance(workdays, pstart, pend, astart, aend) {
            plannedDaysDifference = Math.ceil((pend - pstart) / (1000 * 60 * 60 * 24));
            actualDaysDifference = Math.ceil((aend - astart) / (1000 * 60 * 60 * 24));
            if (workdays == 5) {
                var excludedDays = [0, 6];
                plannedtotalWorkdays = 0;
                actualtotalWorkdays = 0;
                for (var i = 0; i <= plannedDaysDifference - 1; i++) {
                    var tempDate = new Date(pstart);
                    tempDate.setDate(tempDate.getDate() + i)
                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        plannedtotalWorkdays++
                    }
                }
                for (var i = 0; i <= actualDaysDifference - 1; i++) {
                    var tempDate = new Date(astart);
                    tempDate.setDate(tempDate.getDate() + i)

                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        actualtotalWorkdays++
                    }
                }
                var durationInDays = (plannedtotalWorkdays - actualtotalWorkdays);
                durationInDays = durationInDays * -1;
                durationInDays = durationInDays - 1;
                if (durationInDays < 0) {
                    durationInDays = 0;
                }
                return durationInDays;
            }
            if (workdays == 6) {
                var excludedDays = [0];
                plannedtotalWorkdays = 0;
                actualtotalWorkdays = 0;
                for (var i = 0; i <= plannedDaysDifference - 1; i++) {
                    var tempDate = new Date(pstart);
                    tempDate.setDate(tempDate.getDate() + i)
                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        plannedtotalWorkdays++
                    }
                }
                for (var i = 0; i <= actualDaysDifference - 1; i++) {
                    var tempDate = new Date(astart);
                    tempDate.setDate(tempDate.getDate() + i)

                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        actualtotalWorkdays++
                    }
                }
                var durationInDays = (plannedtotalWorkdays - actualtotalWorkdays);
                durationInDays = durationInDays * -1;
                durationInDays = durationInDays - 1;
                if (durationInDays < 0) {
                    durationInDays = 0;
                }
                return durationInDays;
            }
            if (workdays == 7) {
                var excludedDays = [];
                plannedtotalWorkdays = 0;
                actualtotalWorkdays = 0;
                for (var i = 0; i <= plannedDaysDifference - 1; i++) {
                    var tempDate = new Date(pstart);
                    tempDate.setDate(tempDate.getDate() + i)
                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        plannedtotalWorkdays++
                    }
                }
                for (var i = 0; i <= actualDaysDifference - 1; i++) {
                    var tempDate = new Date(astart);
                    tempDate.setDate(tempDate.getDate() + i)

                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        actualtotalWorkdays++
                    }
                }
                var durationInDays = (plannedtotalWorkdays - actualtotalWorkdays);
                durationInDays = durationInDays * -1;
                durationInDays = durationInDays - 1;
                if (durationInDays < 0) {
                    durationInDays = 0;
                }
                return durationInDays;
            }
        }

        function calcPercentage(workdays, startdate, enddate) {
            var currentdate = new Date();
            currentdate.setSeconds(0, 0);
            const timeDifference = enddate - startdate;
            const daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));
            const xdate = new Date(startdate)
            days = -1
            hours = 0
            if (workdays == 5 && startdate && enddate) {
                var excludedDays = [0, 6];
                totalWorkdays = 0;
                hourscompleted = 0
                workcompleted = -1
                workHoursDifference = 0
                workdaysList = []
                for (var i = 0; i <= daysDifference - 1; i++) {
                    var tempDate = new Date(startdate);
                    tempDate.setDate(tempDate.getDate() + i)

                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        totalWorkdays++
                    }


                }



                while (xdate <= currentdate && enddate >= currentdate) {

                    if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                        workcompleted = workcompleted + 1
                    }
                    if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                        chours = currentdate.getHours();
                        xhours = xdate.getHours();
                        if (chours <= 17 && chours > 9) {
                            hoursdiff = chours - xhours
                            hourscompleted = hoursdiff
                        } else if (chours > 17) {
                            workcompleted = workcompleted + 1
                        }
                    }
                    xdate.setDate(xdate.getDate() + 1);
                }
                workHoursDifference = totalWorkdays * 8
                totalHours = (workcompleted * 8) + hourscompleted
                const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                if (startdate <= currentdate && enddate >= currentdate) {

                    return Math.ceil(per)
                }
                else if (startdate > currentdate) {

                    return ("")
                } else {

                    return "0"
                }

            }

            if (workdays == 6 && startdate && enddate) {
                var excludedDays = [0];
                totalWorkdays = 0;
                hourscompleted = 0
                workcompleted = -1
                workHoursDifference = 0
                workdaysList = []
                for (var i = 0; i <= daysDifference - 1; i++) {
                    var tempDate = new Date(startdate);
                    tempDate.setDate(tempDate.getDate() + i)

                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        totalWorkdays++
                    }


                }



                while (xdate <= currentdate && enddate >= currentdate) {

                    if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                        workcompleted = workcompleted + 1
                    }
                    if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                        chours = currentdate.getHours();
                        xhours = xdate.getHours();
                        if (chours <= 17 && chours > 9) {
                            hoursdiff = chours - xhours
                            hourscompleted = hoursdiff
                        } else if (chours > 17) {
                            workcompleted = workcompleted + 1
                        }
                    }
                    xdate.setDate(xdate.getDate() + 1);
                }
                workHoursDifference = totalWorkdays * 8
                totalHours = (workcompleted * 8) + hourscompleted
                const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                if (startdate <= currentdate && enddate >= currentdate) {

                    return Math.ceil(per)
                }
                else if (startdate > currentdate) {

                    return ("")
                } else {

                    return "0"
                }

            }

            if (workdays == 7 && startdate && enddate) {
                var excludedDays = [];
                totalWorkdays = 0;
                hourscompleted = 0
                workcompleted = -1
                workHoursDifference = 0
                workdaysList = []
                for (var i = 0; i <= daysDifference - 1; i++) {
                    var tempDate = new Date(startdate);
                    tempDate.setDate(tempDate.getDate() + i)

                    if (!excludedDays.includes(tempDate.getDay())) {
                        workdaysList.push(tempDate.toDateString())
                        totalWorkdays++
                    }


                }



                while (xdate <= currentdate && enddate >= currentdate) {

                    if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                        workcompleted = workcompleted + 1
                    }
                    if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                        chours = currentdate.getHours();
                        xhours = xdate.getHours();
                        if (chours <= 17 && chours > 9) {
                            hoursdiff = chours - xhours
                            hourscompleted = hoursdiff
                        } else if (chours > 17) {
                            workcompleted = workcompleted + 1
                        }
                    }
                    xdate.setDate(xdate.getDate() + 1);
                }
                workHoursDifference = totalWorkdays * 8
                totalHours = (workcompleted * 8) + hourscompleted
                const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                if (startdate <= currentdate && enddate >= currentdate) {

                    return Math.ceil(per)
                }
                else if (startdate > currentdate) {

                    return ("")
                } else {

                    return "0"
                }

            }

        }

        // Get all dependencies for the current task
        function getTaskDependencies(taskId) {
            const ganttDependencies = getGanttDependencies()
            const taskDependencies = ganttDependencies?.filter(task => task.predecessorId === taskId)
            return taskDependencies
        }

        // With provided workingDays, check if a date is a working day.
        // Note: this can be extended to check for holiday or non-working days
        function isWorkingDay(currentDate, workingDays) {
            const curDate = (typeof currentDate === 'string') ? new Date(currentDate) : currentDate
            const dayOfWeek = curDate.getDay()
            if (workingDays === 5 && (dayOfWeek === DayOfWeek.SATURDAY || dayOfWeek === DayOfWeek.SUNDAY)) {
                return false
            }
            if (workingDays === 6 && dayOfWeek === DayOfWeek.SUNDAY) {
                return false
            }
            
            return true
        }

        // Get the next working day
        function getNextWorkingDate(currentDate, workingDays) {
            // Calculate next date
            const nextDate = new Date(currentDate)
            nextDate.setDate(nextDate.getDate() + 1)
            while(!isWorkingDay(nextDate, workingDays)) {
                nextDate.setDate(nextDate.getDate() + 1)
            }
            return nextDate
        }

        // Get the previous working day
        function getPreviousWorkingDate(currentDate, workingDays) {
            // Calculate next date 
            const prevDate = new Date(currentDate)
            prevDate.setDate(prevDate.getDate() - 1)
            while(!isWorkingDay(prevDate, workingDays)) {
                prevDate.setDate(prevDate.getDate() - 1)
            }
            return prevDate
        }


        // With dependency type of Finish-Start and provided inputs of the current task duration, workingDays
        // and the predecessorEndDate calculate the startDate and endDate for the currennt task
        function finishToStartDates(duration, workingDays, predecessorEndDate) {
            // Calculate start date based on predecessor's end date
            const startDate = getNextWorkingDate(predecessorEndDate, workingDays)

            // Calculate end date based on duration and working days per week
            let remainingDays = duration
            let endDate = new Date(startDate)
            while (remainingDays > 0) {
                if (isWorkingDay(endDate, workingDays)) {
                    remainingDays--
                }
                endDate = getNextWorkingDate(endDate, workingDays)

                //endDate.setDate(endDate.getDate() + 1)
            }

            endDate = getPreviousWorkingDate(endDate, workingDays) //Get the last working day
            return { startDate: startDate.toISOString(), endDate: endDate.toISOString() }
        }

        // With dependency type of Finish-Finish and provided inputs of the current task duration, workingDays
        // and the predecessorEndDate calculate the startDate and endDate for the currennt task
        function finishToFinishDates(duration, workingDays, predecessorEndDate) {
            let endDate = new Date(predecessorEndDate)
            if(!isWorkingDay(endDate, workingDays)) {
                endDate = getPreviousWorkingDate(endDate, workingDays)
            }
            let startDate = new Date(endDate)
            let remainingDays = duration
            while (remainingDays > 0) {
                if (isWorkingDay(startDate, workingDays)) {
                    remainingDays--
                }
                startDate.setDate(startDate.getDate() - 1)
            }
            startDate = getNextWorkingDate(startDate, workingDays) //Get the next working day
            return { startDate: startDate?.toISOString(), endDate: endDate?.toISOString() }
        }

        // With dependency type of Start-Finish and provided inputs of the current task duration, workingDays
        // and the predecessorStartDate calculate the startDate and endDate for the currennt task
        function startToFinishDates(duration, workingDays, predecessorStartDate) {
            // Calculate end date based on predecessor's start date
            const endDate = getPreviousWorkingDate(predecessorStartDate, workingDays)

            // Calculate start date based on duration and working days per week
            let remainingDays = duration
            let startDate = new Date(endDate)
            while (remainingDays > 0) {
                if (isWorkingDay(endDate, workingDays)) {
                    remainingDays--
                }
                startDate = getPreviousWorkingDate(startDate, workingDays)
                //startDate.setDate(startDate.getDate() - 1)
            }

            startDate = getNextWorkingDate(startDate, workingDays) //Get the next working day
            return { startDate: startDate.toISOString(), endDate: endDate.toISOString() }
        }

        // With dependency type of Start-Start and provided inputs of the current task duration, workingDays
        // and the predecessorStartDate calculate the startDate and endDate for the currennt task
        function startToStartDates(duration, workingDays, predecessorStartDate) {
            let startDate = new Date(predecessorStartDate)
            if(!isWorkingDay(startDate, workingDays)) {
                startDate = getNextWorkingDate(startDate, workingDays)
            }
            let endDate = new Date(startDate)
            let remainingDays = duration
            while (remainingDays > 0) {
                if (isWorkingDay(endDate, workingDays)) {
                    remainingDays--
                }
                endDate.setDate(endDate.getDate() + 1)
            }

            endDate = getPreviousWorkingDate(endDate, workingDays) //Get the last working day
            return { startDate: startDate?.toISOString(), endDate: endDate?.toISOString() }
        }
        
        // Update task variancedays
        function updateTaskVariance(taskId) {
            const ganttTasks = getGanttTasks()

            const task = ganttTasks.find(item => item.id === taskId)
            // TODO: >>>> review this - If this is a parent task, calculate variance with workdays as 7?
            if (task?.hasChildren) {
                const variance = calcVariance(7, task.plannedStart, task.plannedEnd, task.start, task.end) ?? 0
                task.set("variancedays", variance)
            } else if (task && task.workdays && task.plannedStart && task.plannedEnd && task.start && task.end) {
                const variance = calcVariance(task.workdays, task.plannedStart, task.plannedEnd, task.start, task.end) ?? 0
                task.set("variancedays", variance)
            }
        }

        // Recursively ppdate parent dates (start, end, durationdays) and its parents
        function updateParentTaskDates(parentId) {
            const ganttTasks = getGanttTasks()

            const parentTask = ganttTasks.find(item => item.id === parentId)
            const childTasks = ganttTasks.filter(item => item.parentId === parentId)

            // Extract start and end dates of child tasks
            const childStartDates = childTasks.map(task => new Date(task.start));
            const childEndDates = childTasks.map(task => new Date(task.end));

            // Find the earliest start date and latest end date among child tasks
            const parentStartDate = new Date(Math.min(...childStartDates));
            const parentEndDate = new Date(Math.max(...childEndDates));

            // Set start and end date for parent task
            parentTask.set('start', parentStartDate.toISOString())
            parentTask.set('end', parentEndDate.toISOString())

            // set durationdays for parent task
            const parentDurationInMilliseconds = parentEndDate - parentStartDate;
            const parentDurationInDays = Math.ceil(parentDurationInMilliseconds / MS_IN_A_DAY);
            parentTask.set('durationdays', parentDurationInDays);

            updateTaskVariance(parentId)

            // If this task has parent task then update the parent task.  This will recursively update all the parent tasks
            if (parentTask.parentId) {
                updateParentTaskDates(parentTask.parentId)
            }

            // Since the startDate and endDate are changed, we need to update its dependencies
            updateTaskDependencies(parentId)
        }

        // Recursively update all task dependencies
        function updateTaskDependencies(taskId) {
            const ganttTasks = getGanttTasks()
            const currentTask = ganttTasks.find(task => task.id === taskId)

            // Get list of dependencies of the current task
            const taskDependencies = getTaskDependencies(taskId)

            // For each of the dependencies, find the successor task and update the startDate and endDate
            // according to the dependency type and the associated date (startDate or endDate) of the predecessor task
            taskDependencies?.map(depItem => {
                depTask = ganttTasks.find(task => task.id === depItem.successorId)
                if (depTask) {
                    let newDates
                    if (depItem.type === DependencyType.FinishStart) {
                        // Handle Finish-Start dependency type
                        newDates = finishToStartDates(depTask.durationdays, depTask.workdays, currentTask.end)
                    } else if (depItem.type === DependencyType.FinishFinish) {
                        // Handle Finish-Finish dependency type
                        newDates = finishToFinishDates(depTask.durationdays, depTask.workdays, currentTask.end)
                    } else if (depItem.type === DependencyType.StartFinish) {
                        // Handle Start-Finish dependency type
                        newDates = startToFinishDates(depTask.durationdays, depTask.workdays, currentTask.start)
                    } else if (depItem.type === DependencyType.StartStart) {
                        // Handle Start-Start dependency type
                        newDates = startToStartDates(depTask.durationdays, depTask.workdays, currentTask.start)
                    } else {
                        // Unknown dependency type. Ignore
                        console.log('Dependency id=' + depItem.id + ' has unknown type: ' + depItem.type)
                        return
                    }

                    // Update the successor task with new startDate and endDate
                    if (newDates) {
                        depTask.set('start', newDates.startDate)
                        depTask.set('end', newDates.endDate)

                        // Note: As the current successor task has the startDate and endDate changed,
                        // we need to update its dependencies recursively
                        updateTaskDependencies(depTask.id)
                    }
                }
            })
        }

        function updateDependencyTaskCallback(callbackInfo) {
            const currentTask = callbackInfo.model

            // Ignore destroy callback. Handle only created and updated events
            if (callbackInfo.updateDependencies?.destroyed.length > 0) {
                return
            }

            // Handle created dependency
            if (callbackInfo.updateDependencies?.created.length > 0) {
                // Need to figure out if the current task is a successor or predecessor
                const dependency = callbackInfo.updateDependencies?.created[0]
                
                if (currentTask?.id === dependency?.successorId) {
                    updatePredecessorTasks(callbackInfo)
                } else if (currentTask?.id === dependency?.predecessorId) {
                    updateSuccessorTasks(callbackInfo)
                } else {
                    console.error('Unknown dependency. Current task is nether a predecessor nor successor')
                }
                return
            }

            /* // Redundant.  The dependency is already updated
            // Handle updated dependency
            if (callbackInfo.updateDependencies?.updated.length > 0) {
                // Need to figure out if the current task is a successor or predecessor
                const updateDependency = callbackInfo.updateDependencies?.updated[0]
                const dependency = getGanttDependencies().find(d => d.successorId === updateDependency.successorId && d.predecessorId === updateDependency.predecessorId)
                if (dependency) {
                    dependency.type = updateDependency.type
                }
            }
            */

            // Handle updated/saved without changing
            if (callbackInfo?.sender?.dependencyData?.predecessorId?.length > 0) {
                updatePredecessorTasks(callbackInfo)
            } else if (callbackInfo?.sender?.dependencyData?.successorId.length > 0) {
                updateSuccessorTasks(callbackInfo)
            }
        }

        /*
        function unflatModel(model) {
            if (model["0"] === "[") {
                return JSON.parse(Object.values(model).join("").split("[object Object]")[0])[0]
                return JSON.parse("".join(model.values()))
            } else {
                return model
            }
        }
        */

        function updatePredecessorTasks(callbackInfo) {
            const successorTask = callbackInfo.model

            // callbackInfo.updateInfo is the kendo-ui dependency object that will be used to send update to the backend
            // we need to update this object with the latest date changes for the successor when a dependency is updated

            const ganttTasks = getGanttTasks()
            let dependencies = getGanttDependencies()
            // Since the new created dependency is not added to the gantt data source dependecies list yet,
            // We need to move this new dependency from created list to current list so we have the dependency data to warlk the tasks.
            // The system will continue to sync the lagged created dependencies to the backend system and update the gantt datasource
            const createdDependencies = callbackInfo.updateDependencies?.created.length > 0 ? [...callbackInfo.updateDependencies?.created] : []
            if (createdDependencies?.length > 0) {
                createdDependencies.forEach(dep => {
                    dependencies.push(dep)
                    callbackInfo.updateDependencies.created.pop()
                })
            }

            const curDependencies = dependencies.filter(dep => dep.successorId === successorTask.id)
            curDependencies?.forEach(function (dep) {
                const predecessorTask = ganttTasks?.find(task => task.id === dep.predecessorId)
                if (predecessorTask) {
                    updateRelatedTasks(predecessorTask.id, predecessorTask.parentId)
                }
            })

            // All the dependencies has been updated, get the latest info for the current successor task
            // and use its info for kendo-ui updateInfo object that is used by Task editor to update to the backend.
            const updateInfo = callbackInfo.updateInfo 
            if (updateInfo) {
                const updatedSuccessorTask = ganttTasks.find(t => t.id === successorTask.id)
                updateInfo.start = updatedSuccessorTask.start
                updateInfo.end = updatedSuccessorTask.end
            }
            refreshGanntView()
        }

        function updateSuccessorTasks(callbackInfo) {
            const predecessorTask = callbackInfo.model

            updateTaskDependencies(predecessorTask.id)
            // All the dependencies has been updated, get the latest info for the current successor task
            // and use its info for kendo-ui updateInfo object that is used by Task editor to update to the backend.

            const updateInfo = callbackInfo.updateInfo
            if (updateInfo) {
                const ganttTasks = getGanttTasks()
                const updatedPredecessorTask = ganttTasks.find(t => t.id === predecessorTask.id)
                updateInfo.start = updatedPredecessorTask.start
                updateInfo.end = updatedPredecessorTask.end
            }
            refreshGanntView()
        }

        // Update the current task info and  all of its related tasks
        // - current task variance
        // - current task dependencies recursively and their parents recursively
        // - current task parent recursively and their dependencies recursively
        function updateRelatedTasks(taskId, parentId) {
            if (!taskId) {
                return
            }
            // Update task variancedays
            updateTaskVariance(taskId)
            
            // Since the startDate and endDate are changed, we need to update its dependencies
            updateTaskDependencies(taskId)

            // Update parent task if exist
            if (parentId) {
                updateParentTaskDates(parentId)
            }

            refreshGanntView()
        }

        function changeValue(showPlanned) {
            var gantt = $('#gantt').data('kendoGantt')
            var datasource = gantt.dataSource;

            function showPlannedColumns(isChecked) {
                gantt.options.columns.forEach(function (column) {

                    if (column.field === "plannedStart" || column.field === "plannedEnd") {
                        column.hidden = !isChecked;
                        column.width = isChecked ? 100 : 0;
                    }
                })
            }
            if (!showPlanned) {
                kendo.confirm("Your action will reset the baselines. Do you wish to continue?").done(function () {
                    //showPlannedColumns(false)
                    baselineSet = false;
                    datasource.data().forEach(function (task) {
                        // if (task.hasChildren == false) {
                        workdays = task.workdays;
                        startdate = task.start;
                        endDate = task.end;

                        if ((workdays == 5) && startdate && endDate) {
                            var loop = new Date(startdate);
                            var z = 0;
                            while (loop <= endDate) {
                                if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                    z = z + 1;
                                }
                                let newDate = loop.setDate(loop.getDate() + 1);
                                loop = new Date(newDate);
                            }
                            task.set("durationdays", z);
                        }
                        if ((workdays == 6) && startdate && endDate) {
                            var loop = new Date(startdate);
                            var z = 0;
                            while (loop <= endDate) {
                                console.log('6- loop-' + loop)
                                console.log('6- endDate-' + endDate)
                                if (loop.getDay() !== 0) {
                                    z = z + 1;

                                }
                                let newDate = loop.setDate(loop.getDate() + 1);
                                loop = new Date(newDate);
                            }
                            task.set("durationdays", z);
                        }
                        if ((workdays == 7) && startdate && endDate) {
                            var loop = new Date(startdate);
                            var z = 0;
                            while (loop <= endDate) {
                                console.log('7- loop-' + loop)
                                console.log('7- endDate-' + endDate)
                                z = z + 1;
                                let newDate = loop.setDate(loop.getDate() + 1);
                                loop = new Date(newDate);
                            }
                            task.set("durationdays", z);
                        }
                        //}

                        task.set("baselineSet", false);
                        task.set("variancedays", 0)
                        task.set("plannedStart", task.start);
                        task.set("plannedEnd", task.end);
                    });

                    gantt.dataSource.sync();
                    //showPlannedColumns(false);
                    console.log('[2] >>> gantt.refresh()')
                    gantt.refresh();

                })
                    .fail(function () {
                        gantt.setOptions({
                            showPlannedTasks: true
                        });
                    });
            }

            else {
                kendo.confirm("Your action will set the baselines. Do you wish to continue?").done(function () {
                    //showPlannedColumns(true)
                    baselineSet = true;
                    gantt.dataSource.data().forEach(function (task) {
                        //if (task.hasChildren == false) {
                        workdays = task.workdays
                        startdate = task.plannedStart
                        endDate = task.plannedEnd
                        percentage = calcPercentage(workdays, startdate, endDate)
                        if (percentage) {
                            task.set("percentComplete", percentage)
                        }
                        else {
                            task.set("percentComplete", 0)
                        }

                        task.set("baselineSet", true);
                        task.set("variancedays", 0)
                        task.set("plannedStart", task.start);
                        task.set("plannedEnd", task.end);

                        //showPlannedColumns(true);

                        //}

                    });
                    gantt.dataSource.sync();
                    console.log('[3] >>> gantt.refresh()')
                    gantt.refresh();
                })
                    .fail(function () {
                        gantt.setOptions({
                            showPlannedTasks: false
                        });
                    });
            }
        }

        $(document).ready(function () {
            var serviceRoot = "https://aragencdsgantt.azurewebsites.net/CDS";
            //var serviceRoot = "https://localhost:44380/CDS";
            var serviceRoot = "https://localhost:5001/CDS";
            var ganttInitialized = false;
            var tasksDataSource = new kendo.data.GanttDataSource({
                transport: {
                    read: {
                        url: serviceRoot + "/GanttTasks",
                        dataType: "json"
                    },
                    update: {
                        url: serviceRoot + "/GanttTasks/Update",
                        dataType: "json",
                        type: "POST"

                    },
                    destroy: {
                        url: serviceRoot + "/GanttTasks/Destroy",
                        dataType: "json"
                    },
                    create: {
                        url: serviceRoot + "/GanttTasks/Create",
                        dataType: "json",
                        type: "POST"
                    },
                    parameterMap: function (options, operation) {
                        if (operation !== "read") {
                            //return { models: kendo.stringify(options.models || [options]) };
                            return { models: options.models || [options] };
                        }
                    }
                },
                schema: {
                    model: {
                        id: "id",
                        fields: {
                            id: { from: "ID", type: "number" },
                            orderId: { from: "OrderID", type: "number", validation: { required: true } },
                            parentId: { from: "ParentID", type: "number", defaultValue: null, nullable: true },
                            start: { from: "Start", type: "date", defaultValue: null, },
                            end: { from: "End", type: "date", defaultValue: null, },
                            plannedStart: { from: "PlannedStart", type: "date", defaultValue: null, nullable: true },
                            plannedEnd: { from: "PlannedEnd", type: "date", defaultValue: null, nullable: true },
                            title: { from: "Title", defaultValue: "", type: "string" },
                            percentComplete: { from: "PercentComplete", type: "number", defaultValue: 0 },
                            summary: { from: "Summary", type: "boolean" },
                            expanded: { from: "Expanded", type: "boolean", defaultValue: true },
                            workdays: { from: "Workdays", type: "number", validation: { required: true }, defaultValue: 5 },
                            taskManager: { from: "TaskManager", type: "string" },
                            durationdays: { from: "DurationDays", type: "number" },
                            variancedays: { from: "VarianceDays", type: "number" },
                            status: { from: "TaskStatus", type: "string" },
                            delayreason: { from: "DelayReason", type: "string" },
                            delaycomments: { from: "DelayComments", type: "string" },
                            remarks: { from: "Remarks", type: "string" }
                        }
                    }
                }
            });

            var dependenciesDataSource = new kendo.data.GanttDependencyDataSource({
                transport: {
                    read: {
                        url: serviceRoot + "/GanttDependencies",
                        dataType: "json"
                    },
                    update: {
                        url: serviceRoot + "/GanttDependencies/Update",
                        contentType: "application/json",
                        dataType: "json",
                        data: function (data) {
                            //Bug: This original JSON stringify data is a big bug.  This cause the data to be encoded over and over again until it is not readable.
                            // This may cause data coruption. This causes the data loading failed and the Task edit dialog can not read the saved dependecy type.
                            // This also cause the issue that after saving the first time, the data can not be loaded so you do not see the data
                            // in the dialog.  When you create the second time, you see the second dependency data but now you have multiple dependency.
                            // It cause an unpredictable behaviour.
                            //return JSON.stringify(data);
                            return data
                        }
                    },
                    destroy: {
                        url: serviceRoot + "/GanttDependencies/Destroy",
                        dataType: "json"
                    },
                    create: {
                        url: serviceRoot + "/GanttDependencies/Create",
                        dataType: "json"
                    },
                    parameterMap: function (options, operation) {
                        if (operation !== "read") {
                            //return { models: kendo.stringify(options.models || [options]) };
                            return { models: options.models || [options] };
                        }
                    }
                },
                schema: {
                    model: {
                        id: "id",
                        fields: {
                            id: { from: "ID", type: "number" },
                            predecessorId: { from: "PredecessorID", type: "number" },
                            successorId: { from: "SuccessorID", type: "number" },
                            type: { from: "Type", type: "number" }
                        }
                    }
                }
            });

            var gantt = $("#gantt").kendoGantt({
                dataSource: tasksDataSource,
                dataBound: function (e) {
                    if (!ganttInitialized) {
                        ganttInitialized = true;

                        gantt.dataSource['_data'].forEach(event => {

                            var startDate = event.start
                            var EndDate = event.end
                            var Workdays = event.workdays
                            var pstart = event.plannedStart
                            var pend = event.plannedEnd
                            percentage = calcPercentage(Workdays, startDate, EndDate)

                            if (percentage) {

                                event.set("percentComplete", percentage);
                            }
                            else {
                                event.set("percentComplete", 0);
                            }

                        });
                        gantt.dataSource.sync();
                        console.log(gantt.dataSource.data());
                        baselineSet = gantt.dataSource.data()[0].BaselineSet;

                        if (baselineSet) {
                            gantt.setOptions({
                                showPlannedTasks: true
                            });
                            // gantt.options.columns.forEach(function (column) {
                            //     if (column.field === "plannedStart" || column.field === "plannedEnd") {
                            //         alert(baselineSet + " " + column.field);
                            //         column.hidden = false;
                            //         //column.width = 100;
                            //     }
                            // });
                            console.log('[4] >>> gantt.refresh()')
                            gantt.refresh();
                        }
                        else {
                            gantt.setOptions({
                                showPlannedTasks: false
                            });
                            // gantt.options.columns.forEach(function (column) {
                            //     if (column.field === "plannedStart" || column.field === "plannedEnd") {
                            //         alert(baselineSet + " " + column.field);
                            //         column.hidden = true;
                            //         //column.width = 0;
                            //     }
                            // });
                            console.log('[5] >>> gantt.refresh()')
                            gantt.refresh();
                        }
                        $('#planned-switch_label').text('Set Baselines');
                    }
                },
                edit: function (e) {
                    var datePickers = $('[data-role="datetimepicker"]');
                    $(datePickers).each(function () {
                        $(this).data("kendoDateTimePicker").setOptions({
                            format: "{0:dd/MM/yyyy}"
                        });
                        $(this).data("kendoDateTimePicker").enable(false);
                    });

                    //var percentComplete = $('[data-role="numerictextbox"]').data("kendoNumericTextBox").enable(false);

                    var tabStrip = $('[data-role="tabstrip"]').data("kendoTabStrip");
                    if (tabStrip != undefined && tabStrip.tabGroup != undefined) {
                        var otherTab = tabStrip.tabGroup.find(".k-tabstrip-item.k-last");
                        otherTab.remove(); //or otherTab.hide()
                    }
                    //var resGrid = $('#resources-grid').data('kendoGrid');
                    //resGrid.hideColumn(1);
                },
                // save: function (e) {
                //     var task = e.task;

                //     if (!e.values.end) {
                //         return;
                //     }

                //     var startDelta = e.values.end - e.task.end;

                //     moveTask(e.sender, task, startDelta)

                //     e.sender.dependencies.filter(null);
                //     e.sender.dataSource.sync();
                // },
                dependencies: dependenciesDataSource,
                resources: {
                    field: "resources",
                    dataColorField: "Color",
                    dataTextField: "Name",
                    dataSource: {
                        transport: {
                            read: {
                                url: serviceRoot + "/GanttResources",
                                dataType: "json"
                            }
                        },
                        schema: {
                            model: {
                                id: "id",
                                fields: {
                                    id: { from: "ID", type: "number" }
                                }
                            }
                        }
                    }
                },
                assignments: {
                    dataTaskIdField: "TaskID",
                    dataResourceIdField: "ResourceID",
                    dataValueField: "Units",
                    dataSource: {
                        transport: {
                            read: {
                                url: serviceRoot + "/GanttResourceAssignments",
                                dataType: "json"
                            },
                            update: {
                                url: serviceRoot + "/GanttResourceAssignments/Update",
                                dataType: "json"
                            },
                            destroy: {
                                url: serviceRoot + "/GanttResourceAssignments/Destroy",
                                dataType: "json"
                            },
                            create: {
                                url: serviceRoot + "/GanttResourceAssignments/Create",
                                dataType: "json"
                            },
                            parameterMap: function (options, operation) {
                                if (operation !== "read") {
                                    return { models: kendo.stringify(options.models || [options]) };
                                }
                            }
                        },
                        schema: {
                            model: {
                                id: "ID",
                                fields: {
                                    ID: { type: "number" },
                                    ResourceID: { type: "number" },
                                    Units: { type: "number" },
                                    TaskID: { type: "number" }
                                }
                            }
                        }
                    }
                },
                views: [
                    { type: "week", selected: true }
                ],
                columns: [
                    { field: "title", title: "Title", editable: true, sortable: true, width: 200 },
                    {
                        field: "workdays", title: "Work Days", editable: true, width: 85,
                        template: function (options) {
                            if (options.hasChildren && options.workdays) {
                                return "";
                            }
                            else {
                                return options.workdays;
                            }
                        },
                        editor: function (container, options) {
                            var isChecked = $("#planned-switch").prop("checked");

                            if (isChecked || options.model.hasChildren) {
                                //container.html(kendo.toString(options.model.workdays));
                                container.html(kendo.toString(""));
                            }
                            else {
                                $('<input name="' + options.field + '"/>')
                                    .appendTo(container)

                                    .kendoDropDownList({
                                        dataTextField: "text",
                                        dataValueField: "value",

                                        dataSource: [
                                            { text: "5", value: "5" },
                                            { text: "6", value: "6" },
                                            { text: "7", value: "7" }
                                        ],
                                        change: function (e) {
                                            var selectedValue = e.sender.value();

                                            options.model.set("workdays", selectedValue);
                                            //console.log(selectedValue)
                                            var durationdays = options.model.durationdays;
                                            var endDate = options.model.end;
                                            var startDate = options.model.start;
                                            // options.model.set("end", endDate);

                                            // Update starting day
                                            while(!isWorkingDay(startDate, options.model.workdays)) {
                                                startDate.setDate(startDate.getDate() + 1)
                                            }

                                            if ((selectedValue == 5) && startDate && durationdays) {
                                                var loop = new Date(startDate);
                                                var z = 0
                                                var days = durationdays
                                                var endDate = endDate
                                                while (days > 0) {
                                                    if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                        z = z + 1
                                                        endDate = loop
                                                        days -= 1
                                                    }
                                                    let newDate = loop.setDate(loop.getDate() + 1);
                                                    loop = new Date(newDate);
                                                }
                                                endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                                options.model.set("end", endDate);
                                            }
                                            else if ((selectedValue == 6) && startDate && durationdays) {
                                                var loop = new Date(startDate);
                                                var z = 0
                                                var days = durationdays
                                                var endDate = endDate
                                                while (days > 0) {
                                                    if (loop.getDay() !== 0) {
                                                        z = z + 1
                                                        endDate = loop
                                                        days -= 1
                                                    }
                                                    let newDate = loop.setDate(loop.getDate() + 1);
                                                    loop = new Date(newDate);
                                                }
                                                endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                                options.model.set("end", endDate);
                                            }
                                            else if ((selectedValue == 7) && startDate && durationdays) {
                                                var loop = new Date(startDate);
                                                var z = 0
                                                var days = durationdays
                                                var endDate = endDate
                                                while (days > 0) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                    let newDate = loop.setDate(loop.getDate() + 1);
                                                    loop = new Date(newDate);
                                                    console.log(loop);
                                                    console.log(days);
                                                }
                                                endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                                options.model.set("end", endDate);
                                            }

                                            else if ((selectedValue == 5) && startDate && endDate) {
                                                var loop = new Date(startDate);
                                                var z = 0
                                                while (loop <= endDate) {
                                                    if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                        z = z + 1

                                                    }
                                                    let newDate = loop.setDate(loop.getDate() + 1);
                                                    loop = new Date(newDate);
                                                }
                                                options.model.set("durationdays", z);
                                            }
                                            else if ((selectedValue == 6) && startDate && endDate) {
                                                var loop = new Date(startDate);
                                                var z = 0
                                                while (loop <= endDate) {
                                                    if (loop.getDay() !== 0) {
                                                        z = z + 1

                                                    }
                                                    let newDate = loop.setDate(loop.getDate() + 1);
                                                    loop = new Date(newDate);
                                                }
                                                options.model.set("durationdays", z);
                                            }
                                            else if ((selectedValue == 7) && startDate && endDate) {
                                                var loop = new Date(startDate);
                                                var z = 0
                                                while (loop <= endDate) {
                                                    z = z + 1
                                                    let newDate = loop.setDate(loop.getDate() + 1);
                                                    loop = new Date(newDate);
                                                }
                                                options.model.set("durationdays", z);
                                            }

                                            // If this task has a predecessor, make sure it startDate or endDate depends on its predecessor
                                            updatePredecessorTasks({ model })

                                            // Note: As the current successor task has the startDate and endDate changed,
                                            // we need to update its dependencies recursively
                                            updateTaskDependencies(options.model.id)
                                        }
                                    });
                            }
                        }
                    },
                    {
                        field: "health", title: "Health", editable: false, width: 80, template: function (dataItem) {
                            var percentCompleted = "";
                            var startdate = dataItem.start
                            var endDate = dataItem.end
                            var workdays = dataItem.workdays

                            if (startdate && endDate && workdays) {
                                workdays = workdays;
                                startdate.setHours(9, 0, 0, 0)
                                var enddate = endDate
                                enddate.setHours(17, 0, 0, 0)
                                var currentdate = new Date();
                                currentdate.setSeconds(0, 0);
                                const timeDifference = enddate - startdate;
                                const daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));
                                const xdate = new Date(startdate)
                                days = -1
                                hours = 0
                                if (workdays == 5) {
                                    var excludedDays = [0, 6];
                                    totalWorkdays = 0;
                                    hourscompleted = 0
                                    workcompleted = -1
                                    workHoursDifference = 0
                                    workdaysList = []
                                    for (var i = 0; i <= daysDifference - 1; i++) {
                                        var tempDate = new Date(startdate);
                                        tempDate.setDate(tempDate.getDate() + i)

                                        if (!excludedDays.includes(tempDate.getDay())) {
                                            workdaysList.push(tempDate.toDateString())
                                            totalWorkdays++
                                        }

                                    }
                                    while (xdate <= currentdate && enddate >= currentdate) {
                                        if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                                            workcompleted = workcompleted + 1
                                        }
                                        if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                                            chours = currentdate.getHours();
                                            xhours = xdate.getHours();

                                            if (chours <= 17 && chours > 9) {
                                                hoursdiff = chours - xhours
                                                hourscompleted = hoursdiff
                                            } else if (chours > 17) {
                                                workcompleted = workcompleted + 1
                                            }

                                        }
                                        xdate.setDate(xdate.getDate() + 1);
                                    }

                                    workHoursDifference = totalWorkdays * 8
                                    totalHours = (workcompleted * 8) + hourscompleted
                                    const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                                    if (startdate <= currentdate && enddate >= currentdate) {

                                        percentCompleted = Math.ceil(per).toString()
                                    }
                                    else if (startdate > currentdate) {
                                        percentCompleted = ""
                                    }
                                    else {
                                        percentCompleted = "0"
                                    }


                                }
                                if (workdays == 6) {
                                    var excludedDays = [0];
                                    totalWorkdays = 0;
                                    hourscompleted = 0
                                    workcompleted = -1
                                    workHoursDifference = 0
                                    workdaysList = []
                                    for (var i = 0; i <= daysDifference - 1; i++) {
                                        var tempDate = new Date(startdate);
                                        tempDate.setDate(tempDate.getDate() + i)

                                        if (!excludedDays.includes(tempDate.getDay())) {
                                            workdaysList.push(tempDate.toDateString())
                                            totalWorkdays++
                                        }

                                    }
                                    while (xdate <= currentdate && enddate >= currentdate) {
                                        if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                                            workcompleted = workcompleted + 1
                                        }
                                        if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                                            chours = currentdate.getHours();
                                            xhours = xdate.getHours();

                                            if (chours <= 17 && chours > 9) {
                                                hoursdiff = chours - xhours
                                                hourscompleted = hoursdiff
                                            } else if (chours > 17) {
                                                workcompleted = workcompleted + 1
                                            }

                                        }
                                        xdate.setDate(xdate.getDate() + 1);
                                    }

                                    workHoursDifference = totalWorkdays * 8
                                    totalHours = (workcompleted * 8) + hourscompleted
                                    const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                                    if (startdate <= currentdate && enddate >= currentdate) {

                                        percentCompleted = Math.ceil(per).toString();
                                    }
                                    else if (startdate > currentdate) {
                                        percentCompleted = ""
                                    }
                                    else {
                                        percentCompleted = "0"
                                    }


                                }
                                if (workdays == 7) {
                                    var excludedDays = [];
                                    totalWorkdays = 0;
                                    hourscompleted = 0
                                    workcompleted = -1
                                    workHoursDifference = 0
                                    workdaysList = []
                                    for (var i = 0; i <= daysDifference - 1; i++) {
                                        var tempDate = new Date(startdate);
                                        tempDate.setDate(tempDate.getDate() + i)

                                        if (!excludedDays.includes(tempDate.getDay())) {
                                            workdaysList.push(tempDate.toDateString())
                                            totalWorkdays++
                                        }

                                    }
                                    while (xdate <= currentdate && enddate >= currentdate) {
                                        if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                                            workcompleted = workcompleted + 1
                                        }
                                        if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                                            chours = currentdate.getHours();
                                            xhours = xdate.getHours();
                                            if (chours <= 17 && chours > 9) {
                                                hoursdiff = chours - xhours
                                                hourscompleted = hoursdiff
                                            } else if (chours > 17) {
                                                workcompleted = workcompleted + 1
                                            }

                                        }
                                        xdate.setDate(xdate.getDate() + 1);
                                    }

                                    workHoursDifference = totalWorkdays * 8
                                    totalHours = (workcompleted * 8) + hourscompleted
                                    const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                                    if (startdate <= currentdate && enddate >= currentdate) {
                                        percentCompleted = Math.ceil(per).toString();
                                    }
                                    else if (startdate > currentdate) {
                                        percentCompleted = ""
                                    }
                                    else {
                                        percentCompleted = "0"
                                    }


                                }

                            }

                            var actualStart = dataItem.start
                            // actualStart.format{0,yyyy,mm,dd}
                            var actualEnd = dataItem.end
                            var currentDate = new Date();

                            var statusField = dataItem.status;
                            if (statusField === "Completed") {
                                return '<div style="background-color: green; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                            else if (percentCompleted === "") {
                                return '<div style="background-color: blue; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                            else if ((percentCompleted == 100) && (statusField != "Completed")) {
                                return '<div style="background-color: green; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                            else if (percentCompleted < 60 && percentCompleted > 0) {
                                return '<div style="background-color: yellow; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                            else if (percentCompleted < 100 && percentCompleted > 0) {
                                return '<div style="background-color: green; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                            else if (percentCompleted === "0") {
                                return '<div style="background-color: red; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                        }
                    },
                    {
                        field: "durationdays", title: "Duration", editable: true, width: 100,
                        editor: function (container, options) {
                            var isChecked = $("#planned-switch").prop("checked");

                            if (isChecked || options.model.hasChildren) {
                                container.html(kendo.toString(options.model.durationdays));
                            }
                            else {
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoNumericTextBox({
                                    min: 1,
                                    change: function (e) {
                                        var selectedValue = e.sender.value();

                                        options.model.set("durationdays", selectedValue);
                                        var durationdays = options.model.durationdays;
                                        var workdays = options.model.workdays;
                                        var startdate = options.model.start;
                                        var endDate = options.model.end

                                        if ((workdays == 5) && startdate) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("end", endDate);
                                        }
                                        else if ((workdays == 6) && startdate) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                if (loop.getDay() !== 0) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("end", endDate);
                                        }
                                        else if ((workdays == 7) && startdate) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {

                                                z = z + 1
                                                endDate = loop
                                                days -= 1

                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("end", endDate);
                                        }

                                        else if (startdate && durationdays) {
                                            // options.model.set("workdays", "5");
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("end", endDate);

                                        }

                                        // If this task has a predecessor, make sure it startDate or endDate depends on its predecessor
                                        updatePredecessorTasks({ model })

                                        // Update the current task info and  all of its related tasks
                                        // - current task duration and variance
                                        // - current task dependencies recursively and their parents recursively
                                        // - current task parent recursively and their dependencies recursively
                                        updateRelatedTasks(options.model.id, options.model.parentId)
                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "planneddays", title: "Planned(days)", editable: false, width: 0,
                        template: function (dataItem) {
                            model = dataItem;
                            var plannedStart = model.start
                            var plannedEnd = model.end
                            var workdays = model.workdays
                            // if(!workdays){
                            //     workdays="5"
                            //     //console.log("not")
                            //     dataItem.set("workdays","5")
                            // }
                            if ((workdays == 5) && plannedStart && plannedEnd) {
                                var loop = new Date(plannedStart);
                                var z = 0
                                while (loop <= plannedEnd) {
                                    if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                        z = z + 1

                                    }
                                    let newDate = loop.setDate(loop.getDate() + 1);
                                    loop = new Date(newDate);
                                }
                                model.planneddays = z
                                return z;
                            }
                            else if ((workdays == 6) && plannedStart && plannedEnd) {
                                var loop = new Date(plannedStart);
                                var z = 0
                                while (loop <= plannedEnd) {
                                    if (loop.getDay() !== 0) {
                                        z = z + 1

                                    }
                                    let newDate = loop.setDate(loop.getDate() + 1);
                                    loop = new Date(newDate);
                                }
                                model.planneddays = z
                                return z;
                            }
                            else if (plannedStart && plannedEnd) {
                                var durationInDays = Math.floor((plannedEnd - plannedStart) / (1000 * 60 * 60 * 24));
                                model.planneddays = durationInDays + 1
                                return durationInDays + 1;
                            }
                            model.planneddays = ""
                            return ""
                        }
                    },
                    {
                        field: "plannedStart", title: "Plan Start Date", defaultValue: "", nullable: true, editable: false, format: "{0:dd/MM/yyyy}", width: 100,
                        editor: function (container, options) {
                            var isChecked = $("#planned-switch").prop("checked");

                            if (isChecked || options.model.hasChildren) {
                                container.html(kendo.toString(options.model.plannedStart, "dd/MM/yyyy"));
                            }
                            else {

                                var days = options.model.workdays;
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: options.model.columnName,
                                    disableDates: ((days) => {
                                        if (days == '5') {
                                            return ["su", "sa"];
                                        }
                                        if (days == '6') {
                                            return ["su"];
                                        }
                                    })(days),
                                    change: function (e) {
                                        var startdate = options.model.plannedStart;
                                        var durationdays = options.model.durationdays;
                                        var workdays = options.model.workdays;
                                        var endDate = options.model.plannedEnd

                                        if ((workdays == 5) && startdate && durationdays) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("plannedEnd", endDate);
                                        }
                                        if ((workdays == 6) && startdate && durationdays) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                if (loop.getDay() !== 0) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("plannedEnd", endDate);
                                        }
                                        if ((workdays == 7) && startdate && durationdays) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                z = z + 1
                                                endDate = loop
                                                days -= 1
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("plannedEnd", endDate);
                                        }
                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "plannedEnd", title: "Plan End Date", editable: false, defaultValue: "", nullable: true, format: "{0:dd/MM/yyyy}", width: 100,
                        editor: function (container, options) {
                            var isChecked = $("#planned-switch").prop("checked");
                            if (isChecked || options.model.hasChildren) {
                                container.html(kendo.toString(options.model.plannedEnd, "dd/MM/yyyy"));
                            }
                            else {
                                var days = options.model.workdays;
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: options.model.columnName,
                                    disableDates: ((days) => {
                                        if (days == '5') {
                                            return ["su", "sa"];
                                        }
                                        if (days == '6') {
                                            return ["su"];
                                        }
                                    })(days), change: function (e) {
                                        var startdate = options.model.plannedStart;
                                        var durationdays = options.model.durationdays;
                                        var workdays = options.model.workdays;
                                        var endDate = options.model.plannedEnd
                                        var astart = options.model.start;
                                        var aend = options.model.end;

                                        if ((workdays == 5) && startdate) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            while (loop <= endDate) {
                                                if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                    z = z + 1

                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            options.model.set("durationdays", z);
                                        }
                                        if ((workdays == 6) && startdate) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            while (loop <= endDate) {
                                                if (loop.getDay() !== 0) {
                                                    z = z + 1

                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            options.model.set("durationdays", z);
                                        }
                                        if ((workdays == 7) && startdate) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            while (loop <= endDate) {

                                                z = z + 1


                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            options.model.set("durationdays", z);
                                        }
                                        if (workdays, startdate, endDate, astart, aend) {
                                            variance = calcVariance(workdays, startdate, endDate, astart, aend)
                                            if (variance) {
                                                options.model.set("variancedays", variance)
                                            }
                                            else {
                                                options.model.set("variancedays", 0)
                                            }
                                        }
                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "start", title: "Start Date", editable: true, format: "{0:dd/MM/yyyy}", width: 100,
                        editor: function (container, options) {
                            if (options.model.hasChildren) {
                                container.html(kendo.toString(options.model.plannedEnd, "dd/MM/yyyy"));
                            }
                            else {

                                var days = options.model.workdays;
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: new Date(),
                                    disableDates: ((days) => {
                                        if (days == '5') {
                                            return ["su", "sa"];
                                        }
                                        if (days == '6') {
                                            return ["su"];
                                        }
                                    })(days),
                                    change: function (e) {
                                        var selectedValue = e.sender.value();

                                        options.model.set("start", selectedValue);
                                        var startdate = options.model.start;
                                        var durationdays = options.model.durationdays;
                                        var workdays = options.model.workdays;
                                        var endDate = options.model.end

                                        if ((workdays == 5) && startdate && durationdays) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            endDate = endDate
                                            options.model.set("end", endDate);
                                        }
                                        else if ((workdays == 6) && startdate && durationdays) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                if (loop.getDay() !== 0) {
                                                    z = z + 1
                                                    endDate = loop
                                                    days -= 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))

                                            options.model.set("end", endDate);
                                        }
                                        else if ((workdays == 7) && startdate && durationdays) {
                                            var loop = new Date(startdate);
                                            var z = 0
                                            var days = durationdays
                                            var endDate = endDate
                                            while (days > 0) {
                                                z = z + 1
                                                endDate = loop
                                                days -= 1
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            endDate = new Date(endDate.setDate(endDate.getDate() - 1))
                                            options.model.set("end", endDate);
                                        }
                                        if (workdays && startdate && endDate) {
                                            endDate.setHours(17, 0, 0, 0)
                                            percentage = calcPercentage(workdays, startdate, endDate)

                                            if (percentage) {
                                                //console.log(options.model.title, percentage)
                                                options.model.set("percentComplete", percentage)
                                            }
                                            else {
                                                options.model.set("percentComplete", 0)
                                            }
                                        }

                                        // Update the current task info and  all of its related tasks
                                        // - current task duration and variance
                                        // - current task dependencies recursively and their parents recursively
                                        // - current task parent recursively and their dependencies recursively
                                        updateRelatedTasks(options.model.id, options.model.parentId)
                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "end", title: "End Date", editable: true, format: "{0:dd/MM/yyyy}", width: 100,
                        editor: function (container, options) {
                            if (options.model.hasChildren) {
                                container.html(kendo.toString(options.model.plannedEnd, "dd/MM/yyyy"));
                            }
                            else {
                                var days = options.model.workdays;
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: options.model.columnName,
                                    disableDates: ((days) => {
                                        if (days == '5') {
                                            return ["su", "sa"];
                                        }
                                        if (days == '6') {
                                            return ["su"];
                                        }
                                    })(days),
                                    change: function (e) {

                                        var selectedValue = e.sender.value();
                                        options.model.set("end", selectedValue);

                                        var startDate = options.model.start;
                                        var endDate = options.model.end;
                                        var durationdays = options.model.durationdays;
                                        var workdays = options.model.workdays;
                                        var pstart = options.model.plannedStart;
                                        var pend = options.model.plannedEnd;

                                        if ((workdays == 5) && startDate && endDate) {
                                            var loop = new Date(startDate);
                                            var z = 0
                                            while (loop <= endDate) {
                                                if (loop.getDay() !== 0 && loop.getDay() !== 6) {
                                                    z = z + 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            options.model.set("durationdays", z);
                                        }
                                        else if ((workdays == 6) && startDate && endDate) {
                                            var loop = new Date(startDate);
                                            var z = 0
                                            while (loop <= endDate) {
                                                if (loop.getDay() !== 0) {
                                                    z = z + 1
                                                }
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            options.model.set("durationdays", z);
                                        }
                                        else if ((workdays == 7) && startDate && endDate) {
                                            var loop = new Date(startDate);
                                            var z = 0
                                            while (loop <= endDate) {
                                                z = z + 1
                                                let newDate = loop.setDate(loop.getDate() + 1);
                                                loop = new Date(newDate);
                                            }
                                            options.model.set("durationdays", z);
                                        }

                                        if (workdays && startDate && endDate) {
                                            percentage = calcPercentage(workdays, startDate, endDate)
                                            if (percentage) {
                                                //console.log(options.model.title, percentage)
                                                options.model.set("percentComplete", percentage)
                                            }
                                            else {
                                                options.model.set("percentComplete", 0)
                                            }
                                        }

                                        if (workdays, pstart, pend, startDate, endDate) {
                                            variance = calcVariance(workdays, pstart, pend, startDate, endDate)
                                            if (variance) {
                                                options.model.set("variancedays", variance)
                                            }
                                            else {
                                                options.model.set("variancedays", 0)
                                            }
                                        }

                                        // Update the current task info and  all of its related tasks
                                        // - current task duration and variance
                                        // - current task dependencies recursively and their parents recursively
                                        // - current task parent recursively and their dependencies recursively
                                        updateRelatedTasks(options.model.id, options.model.parentId)
                                    }
                                });
                            }
                        }
                    },
                    {
                        field: "variancedays", title: "Variance", width: 100, template: function (dataItem) {
                            var model = dataItem;
                            var workdays = dataItem.workdays
                            var plannedstart = dataItem.plannedStart
                            var plannedenddate = dataItem.plannedEnd
                            var actualstart = dataItem.start
                            var actualenddate = dataItem.end

                            if (workdays == 5) {
                                var excludedDays = [0, 6];
                                plannedtotalWorkdays = 0;
                                actualtotalWorkdays = 0;
                                var timeDifference = plannedenddate - plannedstart;
                                var daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));

                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(plannedstart);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        plannedtotalWorkdays++
                                    }
                                }
                                var timeDifference = actualenddate - actualstart;
                                var daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));

                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(actualstart);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        actualtotalWorkdays++
                                    }
                                }
                                var durationInDays = (plannedtotalWorkdays - actualtotalWorkdays);
                                durationInDays = durationInDays * -1;
                                durationInDays = durationInDays - 1;
                                if (durationInDays < 0) {
                                    durationInDays = 0;
                                }
                                return durationInDays;
                            }
                            if (workdays == 6) {
                                var excludedDays = [0];
                                plannedtotalWorkdays = 0;
                                actualtotalWorkdays = 0;
                                var timeDifference = plannedenddate - plannedstart;
                                var daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));

                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(plannedstart);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        plannedtotalWorkdays++
                                    }
                                }
                                var timeDifference = actualenddate - actualstart;
                                var daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));

                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(actualstart);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        actualtotalWorkdays++
                                    }
                                }
                                var durationInDays = (plannedtotalWorkdays - actualtotalWorkdays);
                                durationInDays = durationInDays * -1;
                                durationInDays = durationInDays - 1;
                                if (durationInDays < 0) {
                                    durationInDays = 0;
                                }
                                return durationInDays;
                            }
                            if (workdays == 7) {
                                var excludedDays = [];
                                plannedtotalWorkdays = 0;
                                actualtotalWorkdays = 0;
                                var timeDifference = plannedenddate - plannedstart;
                                var daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));

                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(plannedstart);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        plannedtotalWorkdays++
                                    }
                                }
                                var timeDifference = actualenddate - actualstart;
                                var daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));

                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(actualstart);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        actualtotalWorkdays++
                                    }
                                }
                                var durationInDays = (plannedtotalWorkdays - actualtotalWorkdays);
                                durationInDays = durationInDays * -1;
                                durationInDays = durationInDays - 1;
                                if (durationInDays < 0) {
                                    durationInDays = 0;
                                }
                                return durationInDays;
                            }
                        }
                    },
                    { field: "taskManager", title: "Task Manager", editable: false, width: 200 },
                    {
                        field: "percentComplete", title: "% Complete", type: "number", editable: false, width: 100,
                        template: function (dataItem) {

                            var workdays = dataItem.workdays;

                            var startdate = dataItem.start;
                            startdate.setHours(9, 0, 0, 0)
                            var enddate = dataItem.end;
                            enddate.setHours(17, 0, 0, 0)
                            var currentdate = new Date();
                            currentdate.setSeconds(0, 0);

                            const timeDifference = enddate - startdate;
                            const daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24));
                            const xdate = new Date(startdate)

                            days = -1
                            hours = 0

                            if (workdays == 5) {
                                var excludedDays = [0, 6];
                                totalWorkdays = 0;
                                hourscompleted = 0
                                workcompleted = -1
                                workHoursDifference = 0
                                workdaysList = []
                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(startdate);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        totalWorkdays++
                                    }
                                }

                                while (xdate <= currentdate && enddate >= currentdate) {

                                    if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                                        workcompleted = workcompleted + 1
                                    }
                                    if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                                        chours = currentdate.getHours();
                                        xhours = xdate.getHours();

                                        if (chours <= 17 && chours > 9) {
                                            hoursdiff = chours - xhours
                                            hourscompleted = hoursdiff
                                        } else if (chours > 17) {
                                            workcompleted = workcompleted + 1
                                        }
                                    }
                                    xdate.setDate(xdate.getDate() + 1);
                                }

                                workHoursDifference = totalWorkdays * 8
                                totalHours = (workcompleted * 8) + hourscompleted
                                const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                                if (startdate <= currentdate && enddate >= currentdate) {

                                    return Math.ceil(per)
                                }
                                else if (startdate > currentdate) {

                                    return ("")
                                } else {

                                    return "0"
                                }

                            }
                            if (workdays == 6) {
                                var excludedDays = [0];
                                totalWorkdays = 0;
                                hourscompleted = 0
                                workcompleted = -1
                                workHoursDifference = 0
                                workdaysList = []
                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(startdate);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        totalWorkdays++
                                    }


                                }
                                while (xdate <= currentdate && enddate >= currentdate) {

                                    if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                                        workcompleted = workcompleted + 1
                                    }
                                    if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                                        chours = currentdate.getHours();
                                        xhours = xdate.getHours();

                                        if (chours <= 17 && chours > 9) {
                                            hoursdiff = chours - xhours
                                            hourscompleted = hoursdiff
                                        } else if (chours > 17) {
                                            workcompleted = workcompleted + 1
                                        }
                                    }
                                    xdate.setDate(xdate.getDate() + 1);
                                }

                                workHoursDifference = totalWorkdays * 8
                                totalHours = (workcompleted * 8) + hourscompleted
                                const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                                if (startdate <= currentdate && enddate >= currentdate) {
                                    return Math.ceil(per)
                                }
                                else if (startdate > currentdate) {
                                    return ("")
                                } else {
                                    return "0"
                                }

                            }
                            if (workdays == 7) {
                                var excludedDays = [];
                                totalWorkdays = 0;
                                hourscompleted = 0
                                workcompleted = -1
                                workHoursDifference = 0
                                workdaysList = []
                                for (var i = 0; i <= daysDifference - 1; i++) {
                                    var tempDate = new Date(startdate);
                                    tempDate.setDate(tempDate.getDate() + i)

                                    if (!excludedDays.includes(tempDate.getDay())) {
                                        workdaysList.push(tempDate.toDateString())
                                        totalWorkdays++
                                    }
                                }

                                while (xdate <= currentdate && enddate >= currentdate) {

                                    if (workdaysList.includes(xdate.toDateString()) && xdate < currentdate) {
                                        workcompleted = workcompleted + 1
                                    }
                                    if ((workdaysList.includes(xdate.toDateString()) && xdate.toDateString() == currentdate.toDateString())) {
                                        chours = currentdate.getHours();
                                        xhours = xdate.getHours();

                                        if (chours <= 17 && chours > 9) {
                                            hoursdiff = chours - xhours
                                            hourscompleted = hoursdiff
                                        } else if (chours > 17) {
                                            workcompleted = workcompleted + 1
                                        }
                                    }
                                    xdate.setDate(xdate.getDate() + 1);
                                }

                                workHoursDifference = totalWorkdays * 8
                                totalHours = (workcompleted * 8) + hourscompleted
                                const per = ((workHoursDifference - totalHours) / workHoursDifference) * 100

                                if (startdate <= currentdate && enddate >= currentdate) {
                                    return Math.ceil(per)
                                }
                                else if (startdate > currentdate) {
                                    return ("")
                                } else {
                                    return "0"
                                }
                            }
                            // }
                            return 0
                        }
                    },
                    {
                        field: "status", title: "Task Status", editable: true, width: 200, editor: function (container, options) {
                            $('<input name="' + options.field + '"/>')
                                .appendTo(container)
                                .kendoDropDownList({
                                    dataTextField: "text",
                                    dataValueField: "value",
                                    dataSource: [
                                        { text: "Completed", value: "Completed" },
                                        { text: "In Progress", value: "In Progress" },
                                        { text: "Not Started", value: "Not Started" },
                                        { text: "On Hold", value: "On Hold" }
                                    ],
                                    change: function (e) {

                                        var selectedValue = e.sender.value();
                                        options.model.set("status", selectedValue);
                                    }
                                });
                        }
                    },
                    {
                        field: "delayreason", title: "Delay Reason", editable: true, width: 250, editor: function (container, options) {
                            $('<input name="' + options.field + '"/>')
                                .appendTo(container)
                                .kendoDropDownList({
                                    dataTextField: "text",
                                    dataValueField: "value",
                                    dataSource: [
                                        { text: "Chemistry/Lab Development", value: "Chemistry/Lab Development" },
                                        { text: "Customer Approval", value: "Customer Approval" },
                                        { text: "Documentation", value: "Documentation" },
                                        { text: "Facility Availability", value: "Facility Availability" },
                                        { text: "Manufacturing", value: "Manufacturing" },
                                        { text: "Raw Material", value: "Raw Material" },
                                        { text: "Scope Changed", value: "Scope Changed" }
                                    ], change: function (e) {

                                        var selectedValue = e.sender.value();
                                        options.model.set("delayreason", selectedValue);
                                    }
                                });
                        }
                    },
                    { field: "delaycomments", title: "Delay Comments", type: "text", editable: true, width: 200 },
                    { field: "remarks", title: "Remarks", type: "text", editable: true, width: 200 }
                ],

                loading: true,
                //showPlannedTasks: false,
                toolbar: ["append", "pdf", "plannedTasks"],
                editable: { plannedTasks: true },
                resizable: true,
                showWorkHours: false,
                showWorkDays: false,
                height: 500,
                listWidth: "75%",
                snap: false,
                tooltip: {
                    visible: true
                },
                togglePlannedTasks: function (e) {
                    changeValue(e.showPlannedTasks);
                },
                updateDependencyTaskCallback
            }).data("kendoGantt");


            function moveTask(gantt, task, startDelta) {
                var t = gantt.dependencies.filter({
                    field: "predecessorId",
                    operator: "equals",
                    value: task.id
                });


                $(gantt.dependencies.view()).each(function (index, dependency) {

                    var dependentTask = gantt.dataSource.get(dependency.successorId);
                    var dependentTaskStart = dependentTask.get("start");
                    var dependentTaskEnd = dependentTask.get("end");

                    dependentTask.set("start", new Date(dependentTaskStart.getTime() + startDelta));
                    dependentTask.set("end", new Date(dependentTaskEnd.getTime() + startDelta));

                    gantt.dependencies.filter(null);

                    var nextTask = gantt.dataSource.get(dependentTask.id);

                    moveTask(gantt, nextTask, startDelta)

                });
            }

            // function percentageCalculation(ganttTasks) {
            //     ganttTasks.data().forEach(function (task) {
            //         workdays = task.workdays
            //         startdate = task.start
            //         endDate = task.end
            //         percentage = calcPercentage(workdays, startdate, endDate)
            //         if (percentage) {

            //             task.set("percentComplete", percentage)
            //         }
            //         else {
            //             task.set("percentComplete", 0)
            //         }
            //     });
            //     ganttTasks.sync();
            // }

            // function varianceCalculation(ganttTasks) {
            //     ganttTasks.data().forEach(function (task) {
            //         workdays = task.workdays
            //         pstart = task.plannedStart
            //         pend = task.plannedEnd
            //         astart = task.start
            //         aend = task.end

            //         variance = calcVariance(workdays, pstart, pend, astart, aend)
            //         if (variance) {

            //             task.set("variancedays", variance)
            //         }
            //         else {
            //             task.set("variancedays", 0)
            //         }
            //     });
            //     ganttTasks.sync();
            // }
            $(document).bind("kendo:skinChange", function () {
                console.log('[6] >>> gantt.refresh()')
                gantt.refresh();
            });
        });
    </script>
</div>