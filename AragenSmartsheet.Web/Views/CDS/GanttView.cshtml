@{
    ViewData["Title"] = "CDS Gantt";
}

<style>
    html {
        font-size: 14px;
        font-family: Arial, Helvetica, sans-serif;
    }

    .k-edit-label[for=percentComplete], .k-edit-field[data-container-for=percentComplete] {
        display: none;
    }
</style>

<title>CDS Gantt</title>


<link href="~/css/default-ocean-blue.css" rel="stylesheet" />
<script src="~/js/jquery-3.7.0.min.js"></script>
<script src="~/js/kendo.all.min.js"></script>

<script src="~/js/kendo-ui-license.js"></script>
<script>
    function loadershow() {
        $(".loaderoverlay").show();
    }
    function loaderhide() {
        $(".loaderoverlay").hide();
    }

</script>
<style>
    .loaderoverlay {
        background: rgba(0,0,0,0.2);
        position: absolute;
        width: 100%;
        z-index: 99;
        color: #fff;
        font-weight: bold;
        text-align: center;
        padding: 20px;
        top: 0;
        min-height: 100%;
        height: 200%;
        display: none;
    }

    .minload {
        position: absolute;
        top: 25%;
        font-size: 30px;
        font: bold;
    }
</style>
<div class="loaderoverlay">
    <span class="minload">Please wait...</span>
</div>

<div id="example">
    <div class="row">
        <div class="col-md-9">
            <span style="float:left; font-weight:bold; padding:5px;" class="text-primary">Project Name: @ViewBag.ProjectName</span>
        </div><div class="col-md-3 pull-right" style="float:right;">
            <a class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md" target="_blank" style="float:right;" href="@Url.Action("GanttView_PDF", "CDS", new { FolderID = @ViewBag.FolderID, FolderName = @ViewBag.ProjectName, FolderLink = @ViewBag.ProjectFolderLink})" target="_parent">Export to PDF</a>
            <a class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md" target="_blank" style="float:right;" href="@ViewBag.ProjectResources">Project Resources</a>
        </div>
    </div>
    <div id="gantt" style="height:100%!important;"></div>

    <style>
        .k-gantt {
            font-family: "DejaVu Sans", "Arial", sans-serif;
        }

        /* Hide toolbars during export */
        .k-pdf-export .k-gantt-toolbar {
            display: none;
        }
    </style>

    <script>

        // ================= Gantt data access helper functions ==================

        // Enum for Dependency types
        // Make sure these value are in sync with the backend type definition
        const DependencyType = {
            FinishFinish: 0,
            FinishStart: 1,
            StartFinish: 2,
            StartStart: 3,
        }

        // Enum for day of week
        const DayOfWeek = {
            SUNDAY: 0,
            MONDAY: 1,
            TUESDAY: 2,
            WEDNESDAY: 3,
            THURSDAY: 4,
            FRIDAY: 5,
            SATURDAY: 6,
        }

        const MILISECONDS_PER_DAY = 1000 * 60 * 60 * 24

        // GanttView instance access methods
        function getGanttDataSource() {
            return $('#gantt').data('kendoGantt').dataSource
        }

        function getGanttTasks() {
            return $('#gantt').data('kendoGantt').dataSource.data()
        }

        function getGanttDependencies() {
            return $('#gantt').data('kendoGantt').dependencies.data()
        }

        function getGanttAssignments() {
            return $('#gantt').data('kendoGantt').assignments.dataSource.data()
        }

        function refreshGanntView() {
            $('#gantt').data('kendoGantt')?.refresh()
        }

        function createStartDate(aDate) {
            const startDate = new Date(aDate)
            startDate.setHours(9, 0, 0, 0)   // Set to start at 9:00 AM
            return startDate
        }
        function createEndDate(aDate) {
            const endDate = new Date(aDate)
            endDate.setHours(17, 0, 0, 0)    // Set to end at 5:00 PM
            return endDate
        }
        function getDisableDates(days) {
            if (days == '5') {
                return ["su", "sa"];
            }
            if (days == '6') {
                return ["su"];
            }
        }
        // ==========================================================================

        var baselineSet = false;

        function calcVariance(workdays, pstart, pend, astart, aend) {
            if (!baselineSet) {
                return 0;
            }
            plannedDaysDifference = Math.ceil((pend - pstart) / MILISECONDS_PER_DAY);
            actualDaysDifference = Math.ceil((aend - astart) / MILISECONDS_PER_DAY);
            plannedtotalWorkdays = getWorkEffordDays(pstart, pend, workdays)
            //variance logic updated
            //actualtotalWorkdays = getWorkEffordDays(astart, aend, workdays)
            actualtotalWorkdays = getWorkEffordDays(pstart, aend, workdays)
            var variance = (actualtotalWorkdays - plannedtotalWorkdays) - 1;
            if (variance < 0) {
                variance = 0;
            }
            return variance;
        }

        function calcPercentage(workdays, startDate, endDate) {
            const currentDate = new Date();
            currentDate.setSeconds(0, 0);
            if (currentDate < startDate) { // Project not started yet
                return 0
            }
            if (currentDate > endDate) { // Project has already completed
                return 1
            }

            // Process only prject that endDate has not passed today
            var totalWorkdays = getWorkEffordDays(startDate, endDate, workdays)
            var daysCompleted = getWorkEffordDays(startDate, currentDate, workdays) - 1 // -1 to exclude today
            var todayHoursCompleted = 0

            currentHours = currentDate.getHours();
            // If current time has passed 5:00 PM, then count it as a whole day
            if (currentHours > 17) {
                todayHoursCompleted = 8 // Add fullday hours
            } else if (currentHours > 9) {
                todayHoursCompleted = currentHours - 9  // Add partial hours
            }

            const totalWorkHours = totalWorkdays * 8
            const totalHoursCompleted = (daysCompleted * 8) + todayHoursCompleted
            const percentCompleted = totalWorkHours > totalHoursCompleted ? totalHoursCompleted / totalWorkHours : 0
            return percentCompleted
        }

        // Get all dependencies for the current task
        function getTaskDependencies(taskId) {
            const ganttDependencies = getGanttDependencies()
            const taskDependencies = ganttDependencies?.filter(task => task.predecessorId === taskId)
            return taskDependencies
        }

        // With provided workingDays, check if a date is a working day.
        // Note: this can be extended to check for holiday or non-working days
        function isWorkingDay(currentDate, workingDays) {
            const curDate = (typeof currentDate === 'string') ? new Date(currentDate) : currentDate
            const dayOfWeek = curDate.getDay()
            if (workingDays === 5 && (dayOfWeek === DayOfWeek.SATURDAY || dayOfWeek === DayOfWeek.SUNDAY)) {
                return false
            }
            if (workingDays === 6 && dayOfWeek === DayOfWeek.SUNDAY) {
                return false
            }

            return true
        }

        // Get the next working day
        function getNextWorkingDate(currentDate, workingDays) {
            // Calculate next date
            const nextDate = new Date(currentDate)
            nextDate.setDate(nextDate.getDate() + 1)
            while (!isWorkingDay(nextDate, workingDays)) {
                nextDate.setDate(nextDate.getDate() + 1)
            }
            return nextDate
        }

        // Get the previous working day
        function getPreviousWorkingDate(currentDate, workingDays) {
            // Calculate next date
            const prevDate = new Date(currentDate)
            prevDate.setDate(prevDate.getDate() - 1)
            while (!isWorkingDay(prevDate, workingDays)) {
                prevDate.setDate(prevDate.getDate() - 1)
            }
            return prevDate
        }


        // With dependency type of Finish-Start and provided inputs of the current task duration, workingDays
        // and the predecessorEndDate calculate the startDate and endDate for the currennt task
        function finishToStartDates(duration, workingDays, predecessorEndDate) {
            // Calculate start date based on predecessor's end date
            const startDate = getNextWorkingDate(predecessorEndDate, workingDays)

            // Calculate end date based on duration and working days per week
            let remainingDays = duration
            let endDate = new Date(startDate)
            while (remainingDays > 0) {
                if (isWorkingDay(endDate, workingDays)) {
                    remainingDays--
                }
                endDate = getNextWorkingDate(endDate, workingDays)

                //endDate.setDate(endDate.getDate() + 1)
            }

            endDate = getPreviousWorkingDate(endDate, workingDays) //Get the last working day
            return { startDate: createStartDate(startDate).toISOString(), endDate: createEndDate(endDate).toISOString() }
        }

        // With dependency type of Finish-Finish and provided inputs of the current task duration, workingDays
        // and the predecessorEndDate calculate the startDate and endDate for the currennt task
        function finishToFinishDates(duration, workingDays, predecessorEndDate) {
            let endDate = new Date(predecessorEndDate)
            if (!isWorkingDay(endDate, workingDays)) {
                endDate = getPreviousWorkingDate(endDate, workingDays)
            }
            let startDate = new Date(endDate)
            let remainingDays = duration
            while (remainingDays > 0) {
                if (isWorkingDay(startDate, workingDays)) {
                    remainingDays--
                }
                startDate.setDate(startDate.getDate() - 1)
            }
            startDate = getNextWorkingDate(startDate, workingDays) //Get the next working day
            return { startDate: createStartDate(startDate).toISOString(), endDate: createEndDate(endDate).toISOString() }
        }

        // With dependency type of Start-Finish and provided inputs of the current task duration, workingDays
        // and the predecessorStartDate calculate the startDate and endDate for the currennt task
        function startToFinishDates(duration, workingDays, predecessorStartDate) {
            // Calculate end date based on predecessor's start date
            const endDate = getPreviousWorkingDate(predecessorStartDate, workingDays)

            // Calculate start date based on duration and working days per week
            let remainingDays = duration
            let startDate = new Date(endDate)
            while (remainingDays > 0) {
                if (isWorkingDay(endDate, workingDays)) {
                    remainingDays--
                }
                startDate = getPreviousWorkingDate(startDate, workingDays)
                //startDate.setDate(startDate.getDate() - 1)
            }

            startDate = getNextWorkingDate(startDate, workingDays) //Get the next working day
            return { startDate: createStartDate(startDate).toISOString(), endDate: createEndDate(endDate).toISOString() }
        }

        // With dependency type of Start-Start and provided inputs of the current task duration, workingDays
        // and the predecessorStartDate calculate the startDate and endDate for the currennt task
        function startToStartDates(duration, workingDays, predecessorStartDate) {
            let startDate = new Date(predecessorStartDate)
            if (!isWorkingDay(startDate, workingDays)) {
                startDate = getNextWorkingDate(startDate, workingDays)
            }
            let endDate = new Date(startDate)
            let remainingDays = duration
            while (remainingDays > 0) {
                if (isWorkingDay(endDate, workingDays)) {
                    remainingDays--
                }
                endDate.setDate(endDate.getDate() + 1)
            }

            endDate = getPreviousWorkingDate(endDate, workingDays) //Get the last working day
            return { startDate: createStartDate(startDate).toISOString(), endDate: createEndDate(endDate).toISOString() }
        }

        function getWorkEffordDays(startDate, endDate, workingdays) {
            let workEffordDays = 0
            let curDate = createStartDate(startDate)
            const fullEndDate = createEndDate(endDate)
            while (curDate < fullEndDate) {
                workEffordDays++
                curDate = getNextWorkingDate(curDate, workingdays)
            }
            return workEffordDays
        }

        function getEndDate(startDate, durationdays, workingdays) {
            var curDate = new Date(startDate);
            for (var i = 0; i < durationdays - 1; i++) {
                curDate = getNextWorkingDate(curDate, workingdays)
            }
            return createEndDate(curDate)
        }

        function getStartDate(endDate, durationdays, workingdays) {
            var curDate = new Date(endDate);
            for (var i = 0; i < durationdays - 1; i++) {
                curDate = getPreviousWorkingDate(curDate, workingdays)
            }
            return createStartDate(curDate)
        }

        // perc task variancedays
        function updateTaskVariance(taskInfo) {
            let task = taskInfo
            if (typeof taskInfo === 'number') {
                const ganttTasks = getGanttTasks()
                task = ganttTasks.find(item => item.id === taskInfo)
            }
            if (!baselineSet) {
                task.set("variancedays", 0)
                return 0
            }
            if (task?.hasChildren && task.workdays !== 7) {
                task.set("workdays", 7) // Default parent summary task to 7 days
            }


            var plannedTotalWorkdays = getWorkEffordDays(task.plannedStart, task.plannedEnd, task.workdays);
            //variance logic updated
            //var actualTotalWorkdays = getWorkEffordDays(task.start, task.end, task.workdays);
            var actualTotalWorkdays = getWorkEffordDays(task.plannedStart, task.end, task.workdays);

            var variance = actualTotalWorkdays - plannedTotalWorkdays;
            if (variance < 0) {
                variance = 0
            }
            if (variance !== task.variancedays) {
                task.set("variancedays", variance)
            }
            return variance
        }

        // Recursively update parent dates (start, end, durationdays) and its parents
        function updateParentTaskDates(task) {
            const parentId = task.parentId
            const ganttTasks = getGanttTasks()

            const parentTask = ganttTasks.find(item => item.id === parentId)
            const childTasks = ganttTasks.filter(item => item.parentId === parentId)
            let oldParent = null
            // If this task has a new parent then check if it is already in the child task list.  If not then add it to
            // the child task list of the new parent.  Also remove it from the child task list of the old parent and update
            // the dates and durations for old parent.
            // Note: if task.dirtyFields.parentId is true, this input task is the Kendo ui model callback object which
            // is not one of the tasks in our current task list.  So we need to recalculate the dates and duration for
            // the old parent and new parent of the task base on the parentId info in the Kendo ui model task (with
            // new parentId) and in existing task (with the old parentId).
            if (task.parentId && task?.dirtyFields?.parentId && !childTasks.find(t => t.id === task.id)) {
                // Add the new task to the new parent child list for updating new parent dates
                childTasks.push(task)

                // Update old parent dates
                const oldTask = ganttTasks.find(t => t.id === task.id)
                const oldParentId = oldTask.parentId
                const oldParentTask = ganttTasks.find(t => t.id === oldParentId)

                if (oldParentTask) {
                    const oldChildTasks = ganttTasks.filter(t => t.parentId === oldParentId && t.id !== oldTask.id)
                    // Extract start and end dates of child tasks
                    const oldChildStartDates = oldChildTasks.map(task => new Date(task.start))
                    const oldChildEndDates = oldChildTasks.map(task => new Date(task.end));
                    const oldChildDurationDays = oldChildTasks.map(task => task.durationdays)
                    const oldChildWorkingDays = oldChildTasks.map(task => task.workdays)
                    // Find the earliest start date and latest end date among child tasks
                    const oldParentStartDate = new Date(Math.min(...oldChildStartDates))
                    const oldParentEndDate = new Date(Math.max(...oldChildEndDates))
                    const oldParentWorkingDays = Math.max(...oldChildWorkingDays)
                    oldParentTask.set('workdays', oldParentWorkingDays)
                    // Set start and end date for parent task
                    oldParentTask.set('start', oldParentStartDate.toISOString())
                    oldParentTask.set('end', oldParentEndDate.toISOString())
                    // Set durationdays for parent task
                    //const oldParentDurationInDays = Math.floor((oldParentEndDate - oldParentStartDate) / MILISECONDS_PER_DAY) + 1;
                    const oldParentDurationInDays = getWorkEffordDays(oldParentStartDate, oldParentEndDate, oldParentWorkingDays)
                    oldParentTask.set('durationdays', oldParentDurationInDays);
                }

            }

            // Extract start and end dates of child tasks
            const childStartDates = childTasks.map(task => new Date(task.start));
            const childEndDates = childTasks.map(task => new Date(task.end));
            const childWorkingDays = childTasks.map(task => task.workdays);
            const childDurationDays = childTasks.map(task => task.durationdays);

            // Find the earliest start date and latest end date among child tasks
            const parentStartDate = new Date(Math.min(...childStartDates));
            const parentEndDate = new Date(Math.max(...childEndDates));
            const parentWorkingDays = Math.max(...childWorkingDays)

            // Set start and end date for parent task
            parentTask.set('start', parentStartDate.toISOString())
            parentTask.set('end', parentEndDate.toISOString())

            // set durationdays for parent task
            //const parentDurationInDays = Math.floor((parentEndDate - parentStartDate) / MILISECONDS_PER_DAY) + 1;
            const parentDurationInDays = getWorkEffordDays(parentStartDate, parentEndDate, parentWorkingDays)
            parentTask.set('durationdays', parentDurationInDays);

            updateTaskVariance(parentId)

            // If this task has parent task then update the parent task.  This will recursively update all the parent tasks
            if (parentTask.parentId) {
                updateParentTaskDates(parentTask)
            }

            // Since the startDate and endDate are changed, we need to update its dependencies
            updateTaskDependencies(parentId)
        }

        // Recursively update all task dependencies
        function updateTaskDependencies(taskId) {
            const ganttTasks = getGanttTasks()
            const currentTask = ganttTasks.find(task => task.id === taskId)

            // Get list of dependencies of the current task
            const taskDependencies = getTaskDependencies(taskId)

            // For each of the dependencies, find the successor task and update the startDate and endDate
            // according to the dependency type and the associated date (startDate or endDate) of the predecessor task
            taskDependencies?.map(depItem => {
                depTask = ganttTasks.find(task => task.id === depItem.successorId)
                if (depTask) {
                    let newDates
                    if (depItem.type === DependencyType.FinishStart) {
                        // Handle Finish-Start dependency type
                        newDates = finishToStartDates(depTask.durationdays, depTask.workdays, currentTask.end)
                    } else if (depItem.type === DependencyType.FinishFinish) {
                        // Handle Finish-Finish dependency type
                        newDates = finishToFinishDates(depTask.durationdays, depTask.workdays, currentTask.end)
                    } else if (depItem.type === DependencyType.StartFinish) {
                        // Handle Start-Finish dependency type
                        newDates = startToFinishDates(depTask.durationdays, depTask.workdays, currentTask.start)
                    } else if (depItem.type === DependencyType.StartStart) {
                        // Handle Start-Start dependency type
                        newDates = startToStartDates(depTask.durationdays, depTask.workdays, currentTask.start)
                    } else {
                        // Unknown dependency type. Ignore
                        console.log('Dependency id=' + depItem.id + ' has unknown type: ' + depItem.type)
                        return
                    }

                    // Update the successor task with new startDate and endDate
                    if (newDates) {
                        depTask.set("start", createStartDate(newDates.startDate))
                        depTask.set("end", createEndDate(newDates.endDate))

                        // Note: As the current successor task has the startDate and endDate changed,
                        // we need to update its dependencies recursively
                        updateTaskDependencies(depTask.id)
                    }
                }
            })
        }

        // Check if task1 is a predecessor of task2 or task2's
        function isPredecessor(taskId1, taskId2) {
            if (taskId1 === taskId2) {
                return true
            }
            const dependencies = getGanttDependencies()
            const curDependencies = dependencies?.filter(d => d.predecessorId === taskId1)
            let isDependency = !!curDependencies?.find(d => d.successorId === taskId2)
            if (isDependency) {
                return true
            }

            let subPredecessor = false
            // taskId2 is not direct successor of taskId1, check if taskId2 is a successor of taskId2 dependencies recursively
            curDependencies.forEach(d => {
                if (isPredecessor(d.successorId, taskId2)) {
                    subPredecessor = true
                    return
                }
            })

            return subPredecessor
        }

        // Check if a new dependency will produce a circular dependency
        function isCircularDependency(newDependency) {
            return isPredecessor(newDependency.successorId, newDependency.predecessorId)
        }

        function updateDependencyTaskCallback(callbackInfo) {
            const currentTask = callbackInfo.model ?? callbackInfo.task

            // Ignore destroy callback. Handle only created and updated events
            if (callbackInfo.updateDependencies?.destroyed.length > 0) {
                // return true
            }

            // Handle created dependency
            if (callbackInfo.updateDependencies?.created.length > 0) {
                let validated = true
                let errorMessage = null
                // Need to figure out if the current task is a successor or predecessor
                const dependencies = [...callbackInfo.updateDependencies?.created]
                dependencies.forEach(dependency => {
                    // Check if there are duplicates in created list
                    const duplicates = callbackInfo.updateDependencies?.created.filter(d => (d.successorId === dependency.successorId && d.predecessorId === dependency.predecessorId))
                    if (duplicates?.length > 1) {
                        errorMessage = "There are duplicate dependencies in the list."

                        // Clear the created dependency so that it is not saved to the backend
                        callbackInfo.updateDependencies.created.pop()
                        validated = false
                        return false
                    }

                    // Check if this dependency between successor and predecessor already exist
                    const curDependency = getGanttDependencies().find(d => (d.successorId === dependency.successorId && d.predecessorId === dependency.predecessorId))
                    if (curDependency) {
                        errorMessage = "Sorry, a dependency with the same predecessor already exists."

                        // Clear the created dependency so that it is not saved to the backend
                        callbackInfo.updateDependencies.created.pop()
                        validated = false
                        return false
                    }

                    // Check for circular dependency before proceed to update task with new dependency
                    if (isCircularDependency(dependency)) {
                        errorMessage = "Sorry, you can't create a circular dependency"

                        // Clear the created dependency so that it is not saved to the backend
                        callbackInfo.updateDependencies.created.pop()
                        validated = false
                        return false
                    }
                })
                if (!validated) {
                    if (errorMessage) {
                        kendo.alert(errorMessage)
                    }
                    return false
                }
                if (dependencies.map(d => d.successorId)?.includes(currentTask.id)) {
                    updatePredecessorTasks(callbackInfo)
                } else if (dependencies.map(d => d.predecessorId)?.includes(currentTask.id)) {
                    updateSuccessorTasks(callbackInfo)
                } else {
                    console.error('Unknown dependency. Current task is nether a predecessor nor successor')
                }
                return true
            }


            // Handle updated/saved without changing
            if (callbackInfo?.sender?.dependencyData?.predecessorId?.length > 0) {
                updatePredecessorTasks(callbackInfo)
            } else if (callbackInfo?.sender?.dependencyData?.successorId.length > 0) {
                updateSuccessorTasks(callbackInfo)
            } else if (callbackInfo?.sender?.task?.dirtyFields?.parentId) {
                // ParentId has been changed update the current task with new parent
                updateRelatedTasks(currentTask)
            }
            return true
        }

        function updatePredecessorTasks(callbackInfo) {
            const successorTask = callbackInfo.model ?? callbackInfo.task

            // callbackInfo.updateInfo is the kendo-ui dependency object that will be used to send update to the backend
            // we need to update this object with the latest date changes for the successor when a dependency is updated

            const ganttTasks = getGanttTasks()
            let dependencies = getGanttDependencies()
            // Since the new created dependency is not added to the gantt data source dependecies list yet,
            // We need to move this new dependency from created list to current list so we have the dependency data to warlk the tasks.
            // The system will continue to sync the lagged created dependencies to the backend system and update the gantt datasource
            const createdDependencies = callbackInfo.updateDependencies?.created.length > 0 ? [...callbackInfo.updateDependencies?.created] : []
            if (createdDependencies?.length > 0) {
                createdDependencies.forEach(dep => {
                    dependencies.push(dep)
                    callbackInfo.updateDependencies.created.pop()
                })
            }

            const curDependencies = dependencies.filter(dep => dep.successorId === successorTask.id)
            curDependencies?.forEach(function (dep) {
                const predecessorTask = ganttTasks?.find(task => task.id === dep.predecessorId)
                if (predecessorTask) {
                    updateRelatedTasks(predecessorTask)
                }
            })

            // All the dependencies has been updated, get the latest info for the current successor task
            // and use its info for kendo-ui updateInfo object that is used by Task editor to update to the backend.
            const updateInfo = callbackInfo.updateInfo
            if (updateInfo) {
                const updatedSuccessorTask = ganttTasks.find(t => t.id === successorTask.id)
                updateInfo.start = updatedSuccessorTask.start
                updateInfo.end = updatedSuccessorTask.end
            }
            refreshGanntView()
        }

        function updateSuccessorTasks(callbackInfo) {
            const predecessorTask = callbackInfo.model ?? callbackInfo.task

            updateTaskDependencies(predecessorTask.id)
            // All the dependencies has been updated, get the latest info for the current successor task
            // and use its info for kendo-ui updateInfo object that is used by Task editor to update to the backend.

            const updateInfo = callbackInfo?.updateInfo
            if (updateInfo) {
                const ganttTasks = getGanttTasks()
                const updatedPredecessorTask = ganttTasks.find(t => t.id === predecessorTask.id)
                updateInfo.start = updatedPredecessorTask.start
                updateInfo.end = updatedPredecessorTask.end
            }
            refreshGanntView()
        }

        // Update the current task info and  all of its related tasks
        // - current task variance
        // - current task dependencies recursively and their parents recursively
        // - current task parent recursively and their dependencies recursively
        function updateRelatedTasks(task) {
            if (!task) {
                return
            }
            // Update task variancedays
            updateTaskVariance(task.id)
            // Since the startDate and endDate are changed, we need to update its dependencies
            updateTaskDependencies(task.id)

            // Update the new parent task if exist
            if (task.parentId) {
                updateParentTaskDates(task)
            }

            refreshGanntView();
        }

        function changeValue(showPlanned) {
            var gantt = $('#gantt').data('kendoGantt')
            var datasource = gantt.dataSource;

            function showPlannedColumns(isChecked) {
                gantt.options.columns.forEach(function (column) {

                    if (column.field === "plannedStart" || column.field === "plannedEnd") {
                        column.hidden = !isChecked;
                        column.width = isChecked ? 100 : 0;
                    }
                })
            }
            if (!showPlanned) {
                if (confirm('Your action will reset the baseline. This may take several moments, Do you wish to continue?') == true) {
                    loadershow();
                    // kendo.confirm("Your action will reset the baseline. This may take several moments, Do you wish to continue?").done(function () {
                    //showPlannedColumns(false)
                    debugger;
                    baselineSet = false;
                    datasource.data().forEach(function (task) {

                        const durationdays = getWorkEffordDays(task.start, task.end, task.workdays)
                        task.set("durationdays", durationdays);
                        task.set("baselineSet", false);
                        if (task.variancedays !== 0) {
                            task.set("variancedays", 0)
                        }
                    });

                    gantt.dataSource.sync();
                    //showPlannedColumns(false);
                    gantt.refresh();
                    loaderhide();
                }
                else {
                    gantt.setOptions({
                        showPlannedTasks: true
                    });
                }
            }

            else {
                if (confirm('Your action will set the baseline. This may take several moments, Do you wish to continue?') == true) {
                    // kendo.confirm("Your action will set the baseline. This may take several moments, Do you wish to continue?").done(function () {
                    //showPlannedColumns(true)
                    debugger;
                    loadershow();
                    baselineSet = true;
                    gantt.dataSource.data().forEach(function (task) {

                        //if (task.hasChildren == false) {
                        workdays = task.workdays
                        startdate = task.plannedStart
                        endDate = task.plannedEnd
                        percentage = calcPercentage(workdays, startdate, endDate) ?? 0
                        if (task.percentComplete !== percentage) {
                            task.set("percentComplete", percentage)
                        }

                        task.set("baselineSet", true);
                        if (task.variancedays !== 0) {
                            task.set("variancedays", 0)
                        }
                        if (task.plannedStart?.getTime() !== task.start.getTime()) {
                            task.set("plannedStart", task.start);
                        }
                        if (task.plannedEnd?.getTime() !== task.end.getTime()) {
                            task.set("plannedEnd", task.end);
                        }
                    });
                    gantt.dataSource.sync();
                    //showPlannedColumns(true);
                    gantt.refresh();

                    loaderhide();
                }
                else {
                    gantt.setOptions({
                        showPlannedTasks: false
                    });

                }
            }
        }


        $(document).ready(function () {
            var serviceRoot = "https://aragencdsgantt2.azurewebsites.net/CDS";
            //var serviceRoot = "https://localhost:44380/CDS";
            //var serviceRoot = "https://localhost:5001/CDS";

            var ganttInitialized = false;
            var tasksDataSource = new kendo.data.GanttDataSource({
                transport: {
                    read: {
                        url: serviceRoot + "/GanttTasks",
                        dataType: "json"
                    },
                    update: {
                        url: serviceRoot + "/GanttTasks/Update",
                        dataType: "json",
                        type: "POST"

                    },
                    destroy: {
                        url: serviceRoot + "/GanttTasks/Destroy",
                        dataType: "json"
                    },
                    create: {
                        url: serviceRoot + "/GanttTasks/Create",
                        dataType: "json",
                        type: "POST"
                    },
                    batch: true,
                    parameterMap: function (options, operation) {
                        if (operation !== "read") {
                            return { models: kendo.stringify(options.models || [options]) };
                        }
                    }
                },
                scrollable: false,
                schema: {
                    model: {
                        id: "id",
                        fields: {
                            id: { from: "ID", type: "number" },
                            orderId: { from: "OrderID", type: "number", validation: { required: true } },
                            parentId: { from: "ParentID", type: "number", defaultValue: null, nullable: true },
                            start: { from: "Start", type: "date", defaultValue: null, },
                            end: { from: "End", type: "date", defaultValue: null, },
                            plannedStart: { from: "PlannedStart", type: "date", defaultValue: null, nullable: true },
                            plannedEnd: { from: "PlannedEnd", type: "date", defaultValue: null, nullable: true },
                            title: { from: "Title", defaultValue: "", type: "string" },
                            percentComplete: { from: "PercentComplete", type: "number", defaultValue: 0 },
                            summary: { from: "Summary", type: "boolean" },
                            expanded: { from: "Expanded", type: "boolean", defaultValue: true },
                            workdays: { from: "Workdays", type: "number", validation: { required: true }, defaultValue: 5 },
                            taskManager: { from: "TaskManager", type: "string" },
                            durationdays: { from: "DurationDays", type: "number" },
                            variancedays: { from: "VarianceDays", type: "number" },
                            status: { from: "TaskStatus", type: "string" },
                            delayreason: { from: "DelayReason", type: "string" },
                            delaycomments: { from: "DelayComments", type: "string" },
                            remarks: { from: "Remarks", type: "string" }
                        }
                    }
                }
            });

            var dependenciesDataSource = new kendo.data.GanttDependencyDataSource({
                transport: {
                    read: {
                        url: serviceRoot + "/GanttDependencies",
                        dataType: "json"
                    },
                    update: {
                        url: serviceRoot + "/GanttDependencies/Update",
                        dataType: "json",
                        type: "POST"
                    },
                    destroy: {
                        url: serviceRoot + "/GanttDependencies/Destroy",
                        dataType: "json"
                    },
                    create: {
                        url: serviceRoot + "/GanttDependencies/Create",
                        dataType: "json"
                    },
                    batch: true,
                    parameterMap: function (options, operation) {
                        if (operation !== "read") {
                            return { models: kendo.stringify(options.models || [options]) };
                        }
                    }
                },
                schema: {
                    model: {
                        id: "id",
                        fields: {
                            id: { from: "ID", type: "number" },
                            predecessorId: { from: "PredecessorID", type: "number" },
                            successorId: { from: "SuccessorID", type: "number" },
                            type: { from: "Type", type: "number" }
                        }
                    }
                }
            });

            var gantt = $("#gantt").kendoGantt({
                dataSource: tasksDataSource,
                dataBound: function (e) {
                    if (!ganttInitialized) {
                        ganttInitialized = true;
                        /*
                        gantt.dataSource['_data'].forEach(event => {
                            var startDate = createStartDate(event.start)
                            var endDate = createEndDate(event.end)
                            var workdays = event.workdays
                            var pstart = createStartDate(event.plannedStart)
                            var pend = createEndDate(event.plannedEnd)
                            percentage = calcPercentage(workdays, startDate, endDate)
                            if (event.percentComplete !== percentage) {
                                event.set("percentComplete", (percentage ?? 0));
                            }
                        });
                        */
                        //gantt.dataSource.sync();
                        //console.log(gantt.dataSource.data());
                        //console.log(gantt.dependencies.data());
                        if (gantt.dataSource.data().length > 0) {
                            baselineSet = gantt.dataSource.data()[0].BaselineSet;
                        }
                        gantt.setOptions({ showPlannedTasks: baselineSet });
                        gantt.refresh();
                        $('#planned-switch_label').text('Set Baseline');
                    }
                },
                edit: function (e) {
                    var datePickers = $('[data-role="datetimepicker"]');
                    $(datePickers).each(function () {
                        $(this).data("kendoDateTimePicker").setOptions({
                            format: "{0:dd/MM/yyyy}"
                        });
                        $(this).data("kendoDateTimePicker").enable(false);
                    });

                    //var percentComplete = $('[data-role="numerictextbox"]').data("kendoNumericTextBox").enable(false);

                    var tabStrip = $('[data-role="tabstrip"]').data("kendoTabStrip");
                    if (tabStrip != undefined && tabStrip.tabGroup != undefined) {
                        var otherTab = tabStrip.tabGroup.find(".k-tabstrip-item.k-last");
                        otherTab.remove(); //or otherTab.hide()
                    }
                    //var resGrid = $('#resources-grid').data('kendoGrid');
                    //resGrid.hideColumn(1);
                },
                /*
                save: function (e) {
                    if (!updateDependencyTaskCallback(e)) {
                        e.preventDefault()
                        return false
                    }
                    return true
                },
                */
                add: function (e) {
                    const isBaselineSet = getGanttTasks()[0].BaselineSet
                    const startDate = createStartDate(new Date())
                    const endDate = createEndDate(new Date)
                    endDate.setDate(endDate.getDate() + 2)
                    const task = e.task
                    task.set('start', startDate)
                    task.set('end', endDate)
                    const newDuration = getWorkEffordDays(task.start, task.end, task.workdays)
                    if (task.durationdays != newDuration) {
                        task.set("durationdays", newDuration)
                    }

                    task.set('plannedStart', isBaselineSet ? new Date(startDate) : null)
                    task.set('plannedEnd', isBaselineSet ? new Date(endDate) : null)
                    task.set("planneddays", newDuration)

                    return true
                },
                dependencies: dependenciesDataSource,
                resources: {
                    // filter: "startswith",
                    field: "resources",
                    dataColorField: "Color",
                    dataTextField: "Name",
                    dataSource: {
                        transport: {
                            read: {
                                url: serviceRoot + "/GanttResources",
                                dataType: "json"
                            }
                        },
                        schema: {
                            model: {
                                id: "id",
                                fields: {
                                    id: { from: "ID", type: "number" }
                                }
                            }
                        }
                    }
                },
                assignments: {
                    // filter: "startswith",
                    dataTaskIdField: "TaskID",
                    dataResourceIdField: "ResourceID",
                    dataValueField: "Units",
                    dataSource: {
                        transport: {
                            read: {
                                url: serviceRoot + "/GanttResourceAssignments",
                                dataType: "json"
                            },
                            update: {
                                url: serviceRoot + "/GanttResourceAssignments/Update",
                                dataType: "json"
                            },
                            destroy: {
                                url: serviceRoot + "/GanttResourceAssignments/Destroy",
                                dataType: "json"
                            },
                            create: {
                                url: serviceRoot + "/GanttResourceAssignments/Create",
                                dataType: "json"
                            },
                            parameterMap: function (options, operation) {
                                if (operation !== "read") {
                                    return { models: kendo.stringify(options.models || [options]) };
                                }
                            }
                        },
                        schema: {
                            model: {
                                id: "ID",
                                fields: {
                                    ID: { type: "number" },
                                    ResourceID: { type: "number" },
                                    Units: { type: "number" },
                                    TaskID: { type: "number" }
                                }
                            }
                        }
                    }
                },
                views: [
                    { type: "day" },
                    { type: "week", selected: true },
                    { type: "month" },
                    { type: "year" },
                ],
                columns: [
                    
                    { field: "id", title: "ID", width: 50, visible: false },
                    {
                        field: "title", title: "Title", editable: true, sortable: true, width: 200,
                        template: function (task) {
                            let level = 0
                            // Count parents
                            const tasks = getGanttTasks()
                            let parentId = task.parentId
                            while (parentId) {
                                level++
                                parentTask = tasks.find(t => t.id === parentId)
                                parentId = parentTask?.parentId
                            }
                            const indentSize = task.hasChildren ? 4 : 8; // Number of spaces per indent level
                            const indent = "&nbsp;".repeat(indentSize); // HTML encoded space character for indent
                            // Generate indents based on the level of orderId
                            let indents = "";
                            for (let i = 0; i < level; i++) {
                                indents += indent;
                            }
                            const displayTitle = indents + task.title;
                            return kendo.toString(displayTitle);
                        }
                    },
                    {
                        field: "workdays", title: "Work Days", editable: true, width: 85,
                        template: function (options) {
                            if (options.hasChildren && options.workdays) {
                                return "";
                            }
                            else {
                                return options.workdays;
                            }
                        },
                        editor: function (container, options) {
                            const task = options.model
                            var isChecked = $("#planned-switch").prop("checked");

                            if (isChecked || task.hasChildren) {
                                //container.html(kendo.toString(options.model.workdays));
                                container.html(kendo.toString(""));
                            }
                            else {
                                $('<input name="' + options.field + '"/>')
                                    .appendTo(container)

                                    .kendoDropDownList({
                                        dataTextField: "text",
                                        dataValueField: "value",

                                        dataSource: [
                                            { text: "5", value: "5" },
                                            { text: "6", value: "6" },
                                            { text: "7", value: "7" }
                                        ],
                                        change: function (e) {
                                            if (task.workdays !== e.sender.value()) {
                                                task.set("workdays", e.sender.value());
                                            }
                                            var startDate = new Date(task.start);

                                            // Update starting day
                                            if (!isWorkingDay(startDate, task.workdays)) {
                                                startDate = getNextWorkingDate(startDate, task.workdays)
                                                const newStartDate = createStartDate(startDate)
                                                if (task.start.getTime() !== newStartDate.getTime()) {
                                                    task.set("start", newStartDate)
                                                }
                                            }
                                            if (task.durationdays) {
                                                let curDate = new Date(startDate)
                                                for (var i = 0; i < task.durationdays - 1; i++) {
                                                    curDate = getNextWorkingDate(curDate, task.workdays)
                                                }
                                                const newEndDate = createEndDate(curDate)
                                                if (task.end.getTime() !== newEndDate.getTime()) {
                                                    task.set("end", newEndDate)
                                                }
                                            } else {
                                                const newDuration = getWorkEffordDays(task.start, task.end, task.workdays)
                                                if (task.durationdays != newDuration) {
                                                    task.set("durationdays", newDuration)
                                                }
                                            }


                                            // If this task has a predecessor, make sure it startDate or endDate depends on its predecessor
                                            updatePredecessorTasks({ task })

                                            // Note: As the current successor task has the startDate and endDate changed,
                                            // we need to update its dependencies recursively
                                            updateTaskDependencies(task.id)
                                        }
                                    });
                            }
                        }
                    },
                    {
                        field: "health", title: "Health", editable: false, width: 80, template: function (dataItem) {
                            var percentCompleted = calcPercentage(dataItem.workdays, dataItem.start, dataItem.end)

                            var actualStart = dataItem.start
                            // actualStart.format{0,yyyy,mm,dd}
                            var actualEnd = dataItem.end
                            var currentDate = new Date();

                            var statusField = dataItem.status;
                            if (statusField === "Completed" || percentCompleted < .60) {
                                return '<div style="background-color: green; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                            else if (percentCompleted < 1) {
                                return '<div style="background-color: yellow; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            } else {
                                return '<div style="background-color: red; border: 0px solid; border-radius:10px; height:20px; width:20px;" ></div>';
                            }
                        }
                    },
                    {
                        field: "durationdays", title: "Duration", editable: true, width: 100,
                        editor: function (container, options) {
                            const task = options.model ?? options.task
                            var isChecked = $("#planned-switch").prop("checked");

                            if (isChecked || task.hasChildren) {
                                container.html(kendo.toString(task.durationdays));
                            }
                            else {
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoNumericTextBox({
                                    min: 1,
                                    change: function (e) {
                                        var durationdays = e.sender.value();
                                        if (task.durationdays !== durationdays) {
                                            task.set("durationdays", durationdays);
                                        }
                                        var endDate = new Date(task.start);
                                        for (var i = 0; i < durationdays - 1; i++) {
                                            endDate = getNextWorkingDate(endDate, task.workdays)
                                        }
                                        const newEndDate = createEndDate(endDate)
                                        if (task.end.getTime() !== newEndDate.getTime()) {
                                            task.set("end", newEndDate)
                                        }


                                        // If this task has a predecessor, make sure it startDate or endDate depends on its predecessor
                                        updatePredecessorTasks({ task })

                                        // Update the current task info and  all of its related tasks
                                        // - current task duration and variance
                                        // - current task dependencies recursively and their parents recursively
                                        // - current task parent recursively and their dependencies recursively
                                        updateRelatedTasks(task)
                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "planneddays", title: "Planned(days)", editable: false, width: 0,
                        template: function (task) {
                            task.planneddays = getWorkEffordDays(task.start, task.end, task.workdays)
                            return task.planneddays
                        }
                    },
                    {
                        field: "plannedStart", title: "Plan Start Date", defaultValue: "", nullable: true, editable: false, format: "{0:dd/MM/yyyy}", width: 100,
                        template: function (task) {
                            if (!task.plannedStart) {
                                return ""
                            }
                            task.plannedStart = createStartDate(task.plannedStart)
                            return kendo.toString(task.plannedStart, "dd/MM/yyyy")
                        },
                        editor: function (container, options) {
                            const task = options.model
                            var isChecked = $("#planned-switch").prop("checked");

                            if (isChecked || task.hasChildren) {
                                container.html(kendo.toString(task.plannedStart, "dd/MM/yyyy"));
                            }
                            else {

                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: task.columnName,
                                    disableDates: getDisableDates(task.workdays),
                                    change: function (e) {
                                        const newPlannedStart = createStartDate(task.plannedStart)
                                        if (task.plannedStart !== newPlannedStart) {
                                            task.set("plannedStart", newPlannedStart)
                                        }

                                        var endDate = new Date(task.plannedStart);
                                        var durationdays = task.durationdays;
                                        for (var i = 0; i < durationdays - 1; i++) {
                                            endDate = getNextWorkingDate(endDate, task.workdays)
                                        }
                                        const newEndDate = createEndDate(endDate)
                                        if (task.plannedEnd.getTime() !== newEndDate.getTime()) {
                                            task.set("plannedEnd", newEndDate)
                                        }

                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "plannedEnd", title: "Plan End Date", editable: false, defaultValue: "", nullable: true, format: "{0:dd/MM/yyyy}", width: 100,
                        template: function (task) {
                            if (!task.plannedEnd) {
                                return ""
                            }
                            task.plannedEnd = createEndDate(task.plannedEnd)
                            return kendo.toString(task.plannedEnd, "dd/MM/yyyy")
                        },
                        editor: function (container, options) {
                            const task = options.model
                            var isChecked = $("#planned-switch").prop("checked");
                            if (isChecked || task.hasChildren) {
                                container.html(kendo.toString(task.plannedEnd, "dd/MM/yyyy"));
                            }
                            else {
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: task.columnName,
                                    disableDates: getDisableDates(task.workdays),
                                    change: function (e) {
                                        const newWorkEffordDays = getWorkEffordDays(task.plannedStart, task.plannedEnd, task.workdays)
                                        if (task.durationdays !== newWorkEffordDays) {
                                            task.set("durationdays", newWorkEffordDays)
                                        }
                                        updateTaskVariance(task)
                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "start", title: "Start Date", editable: true,
                        template: function (task) {
                            task.start = createStartDate(task.start)
                            return kendo.toString(task.start, "dd/MM/yyyy")
                        },
                        format: "{0:dd/MM/yyyy}", width: 100,
                        editor: function (container, options) {
                            const task = options.model
                            if (task.hasChildren) {
                                container.html(kendo.toString(task.start, "dd/MM/yyyy"));
                            }
                            else {
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: task.start,
                                    disableDates: getDisableDates(task.workdays),
                                    change: function (e) {
                                        const newStartDate = createStartDate(e.sender.value())
                                        if (task.start.getTime() !== newStartDate.getTime()) {
                                            task.set("start", newStartDate);
                                        }
                                        const newEndDate = getEndDate(task.start, task.durationdays, task.workdays)
                                        if (task.end.getTime() !== newEndDate.getTime()) {
                                            task.set("end", newEndDate)
                                        }
                                        const percentComplete = calcPercentage(task.workdays, task.start, task.end)
                                        if (percentComplete !== task.percentComplete) {
                                            task.set("percentComplete", percentComplete)
                                        }

                                        // Update the current task info and  all of its related tasks
                                        // - current task duration and variance
                                        // - current task dependencies recursively and their parents recursively
                                        // - current task parent recursively and their dependencies recursively
                                        updateRelatedTasks(task)
                                    }
                                })
                            }
                        }
                    },
                    {
                        field: "end", title: "End Date", editable: true,
                        template: function (task) {
                            task.end = createEndDate(task.end)
                            return kendo.toString(task.end, "dd/MM/yyyy")
                        },
                        format: "{0:dd/MM/yyyy}",
                        width: 100,
                        editor: function (container, options) {
                            const task = options.model
                            if (task.hasChildren) {
                                container.html(kendo.toString(task.end, "dd/MM/yyyy"));
                            }
                            else {
                                var input = $('<input name="' + options.field + '"/>').appendTo(container)
                                input.kendoDatePicker({
                                    format: "dd/MM/yyyy",
                                    value: task.end,
                                    disableDates: getDisableDates(task.workdays),
                                    change: function (e) {
                                        const newEndDate = createEndDate(e.sender.value())
                                        if (task.end.getTime() !== newEndDate.getTime()) {
                                            task.set("end", newEndDate)
                                        }

                                        var durationdays = getWorkEffordDays(task.start, task.end, task.workdays) ?? 0
                                        if (task.durationdays !== durationdays) {
                                            task.set("durationdays", durationdays)
                                        }

                                        percentage = calcPercentage(task.workdays, task.start, task.end)
                                        if (task.percentComplete !== percentage) {
                                            task.set("percentComplete", (percentage))
                                        }

                                        // Update the current task info and  all of its related tasks
                                        // - current task duration and variance
                                        // - current task dependencies recursively and their parents recursively
                                        // - current task parent recursively and their dependencies recursively
                                        updateRelatedTasks(task)
                                    }
                                });
                            }
                        }
                    },
                    {
                        field: "variancedays", title: "Variance", width: 50, template: function (dataItem) {
                            return updateTaskVariance(dataItem)
                        }
                    },
                    {
                        field: "taskManager", title: "Task Manager", editable: true, width: 200, editor: function (container, options) {
                            const task = options.model
                            if (task.hasChildren) {
                                container.html(task.taskManager)
                            }
                            else {
                                const task = options.model
                                $('<input name="' + options.field + '"/>')
                                    .appendTo(container)
                                    .kendoDropDownList({
                                        //filter: "startswith",
                                        field: "resources",
                                        dataColorField: "Color",
                                        dataTextField: "Name",
                                        dataValueField: "Name",
                                        dataSource: {
                                            transport: {
                                                read: {
                                                    url: serviceRoot + "/GanttResources",
                                                    dataType: "json"
                                                }
                                            },
                                            schema: {
                                                model: {
                                                    id: "ID",
                                                    fields: {
                                                        id: { from: "Id", type: "number" }
                                                    }
                                                }
                                            }
                                        },
                                        change: function (e) {
                                            if (task.taskManager !== e.sender.text()) {
                                                task.set("taskManager", e.sender.text());
                                            }
                                        }
                                    });
                            }
                        }
                    },
                    {
                        field: "percentComplete", title: "% Complete", type: "number", editable: false, width: 100,
                        template: function (dataItem) {
                            const percentComplete = calcPercentage(dataItem.workdays, dataItem.start, dataItem.end)
                            return Math.round((percentComplete ?? 0) * 100)
                        }
                    },
                    {
                        field: "status", title: "Task Status", editable: true, width: 200, editor: function (container, options) {
                            const task = options.model
                            if (task.hasChildren) {
                                container.html(task.taskManager)
                            }
                            else {
                                $('<input name="' + options.field + '"/>')
                                    .appendTo(container)
                                    .kendoDropDownList({
                                        dataTextField: "text",
                                        dataValueField: "value",
                                        dataSource: [
                                            { text: "Completed", value: "Completed" },
                                            { text: "In Progress", value: "In Progress" },
                                            { text: "Not Started", value: "Not Started" },
                                            { text: "On Hold", value: "On Hold" }
                                        ],
                                        change: function (e) {
                                            if (task.status !== e.sender.value()) {
                                                task.set("status", e.sender.value());
                                            }
                                        }
                                    });
                            }
                        }
                    },
                    {
                        field: "delayreason", title: "Delay Reason", editable: true, width: 250, editor: function (container, options) {
                            const task = options.model
                            if (task.hasChildren) {
                                container.html(task.taskManager)
                            }
                            else {
                                $('<input name="' + options.field + '"/>')
                                    .appendTo(container)
                                    .kendoDropDownList({
                                        dataTextField: "text",
                                        dataValueField: "value",
                                        dataSource: [
                                            { text: "Chemistry/Lab Development", value: "Chemistry/Lab Development" },
                                            { text: "Customer Approval", value: "Customer Approval" },
                                            { text: "Documentation", value: "Documentation" },
                                            { text: "Facility Availability", value: "Facility Availability" },
                                            { text: "Manufacturing", value: "Manufacturing" },
                                            { text: "Raw Material", value: "Raw Material" },
                                            { text: "Scope Changed", value: "Scope Changed" }
                                        ], change: function (e) {
                                            if (task.delayreason !== e.sender.values) {
                                                task.set("delayreason", e.sender.value());
                                            }
                                        }
                                    });
                            }
                        }
                    },
                    { field: "delaycomments", title: "Delay Comments", type: "text", editable: true, width: 200 },
                    { field: "remarks", title: "Remarks", type: "text", editable: true, width: 200 }
                ],
                sortable: true,
                columnResize: () => gantt.refresh(),
                toggle: true,
                loading: true,
                //showPlannedTasks: false,
                toolbar: ["append", "plannedTasks"],
                editable: { plannedTasks: true, resize: false, move: false },
                resizable: true,
                showWorkHours: false,
                showWorkDays: false,
                // height: 100%,
                listWidth: "70%",
                snap: false,
                tooltip: {
                    visible: true
                },
                pdf: {
                    fileName: "Kendo UI Gantt Export.pdf"
                    // proxyURL: "https://demos.telerik.com/kendo-ui/service/export"
                },
                togglePlannedTasks: function (e) {
                    changeValue(e.showPlannedTasks);
                },
                updateDependencyTaskCallback
            }).data("kendoGantt");
            // Intercept event after dependency is saved, we need to assigned the new created dependency
            // and ID, other wise the id of 0 will be treated as a new dependency to be
            $("#gantt").data("kendoGantt").dataSource.bind("requestEnd", function (e) {
                if (e.type === "create") {
                    gantt.dataSource.read();
                }
            });
            // Intercept event after dependency is saved, we need to assigned the new created dependency
            // and ID, other wise the id of 0 will be treated as a new dependency to be
            $('#gantt').data('kendoGantt').dependencies.bind("requestEnd", function (e) {
                const TEMP_ID = 9999
                if (e.type === "create") {
                    // This code will be executed after data is saved
                    const newDependency = getGanttDependencies().find(d => d.id === 0)
                    if (newDependency) {
                        newDependency.id = TEMP_ID
                    }
                    console.log("Data saved successfully");
                }
            });
            $(document).bind("kendo:skinChange", function () {
                gantt.refresh();
            });
        });
    </script>
</div>
